# HG changeset patch
# Parent 1553e79952052b1315e881a5e5c322d07e203dfb

diff -r 1553e7995205 configs/common/Benchmarks.py
--- a/configs/common/Benchmarks.py	Fri Oct 05 14:14:36 2012 -0400
+++ b/configs/common/Benchmarks.py	Fri Oct 12 16:01:36 2012 -0400
@@ -52,7 +52,8 @@
         if self.diskname:
             return disk(self.diskname)
         elif buildEnv['TARGET_ISA'] == 'alpha':
-            return env.get('LINUX_IMAGE', disk('linux-latest.img'))
+            #return env.get('LINUX_IMAGE', disk('linux-latest.img'))
+            return env.get('LINUX_IMAGE', disk('linux-parsec-2-1-m5-with-test-inputs.img'))
         elif buildEnv['TARGET_ISA'] == 'x86':
             return env.get('LINUX_IMAGE', disk('x86root.img'))
         elif buildEnv['TARGET_ISA'] == 'arm':
diff -r 1553e7995205 configs/example/nvm_classic.py
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/configs/example/nvm_classic.py	Fri Oct 12 16:01:36 2012 -0400
@@ -0,0 +1,193 @@
+# Copyright (c) 2006-2008 The Regents of The University of Michigan
+# All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions are
+# met: redistributions of source code must retain the above copyright
+# notice, this list of conditions and the following disclaimer;
+# redistributions in binary form must reproduce the above copyright
+# notice, this list of conditions and the following disclaimer in the
+# documentation and/or other materials provided with the distribution;
+# neither the name of the copyright holders nor the names of its
+# contributors may be used to endorse or promote products derived from
+# this software without specific prior written permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+#
+# Author: Matt Poremba
+
+
+import os
+import optparse
+import sys
+from os.path import join as joinpath
+
+import m5
+from m5.defines import buildEnv
+from m5.objects import *
+from m5.util import addToPath, fatal
+
+if buildEnv['FULL_SYSTEM']:
+    fatal("This script requires syscall emulation mode (*_SE).")
+
+addToPath('../common')
+addToPath('../topologies')
+addToPath('../ruby')
+
+import Options
+import Ruby
+import Simulation
+import CacheConfig
+from Caches import *
+from cpu2000 import *
+
+
+
+# Get paths we might need.  It's expected this file is in m5/configs/example.
+config_path = os.path.dirname(os.path.abspath(__file__))
+config_root = os.path.dirname(config_path)
+m5_root = os.path.dirname(config_root)
+
+parser = optparse.OptionParser()
+Options.addCommonOptions(parser)
+Options.addSEOptions(parser)
+
+if '--ruby' in sys.argv:
+    Ruby.define_options(parser)
+
+# Benchmark options
+parser.add_option("--stdout", action="store_true", help="Print benchmark output to stdout instead of a file.")
+#parser.add_option("-c", "--cmd",
+#    default=joinpath(m5_root, "tests/test-progs/hello/bin/%s/linux/hello" % \
+#            buildEnv['TARGET_ISA']),
+#    help="The binary to run in syscall emulation mode.")
+#parser.add_option("-o", "--options", default="",
+#    help='The options to pass to the binary, use " " around the entire string')
+parser.add_option("--nvmain_PARAM", type="string", default="NULL", help="Set NVMain configuration value for PARAM (e.g., --nvmain_RANKS 4, --nvmain_BANKS 8, etc.)");
+
+
+#
+#  Check for extra nvmain configuration override options and add them as options to python
+#
+argnum = 1
+for arg in sys.argv:
+    if arg[:9] == "--nvmain_":
+        parser.add_option(arg, type="string", default="NULL", help="Set NVMain configuration value for PARAM")
+    argnum = argnum + 1
+
+execfile(os.path.join(config_root, "common", "Options.py"))
+
+
+#
+#  Parse arguments
+#
+(options, args) = parser.parse_args()
+
+
+numThreads = 1
+
+
+#
+#  Setup CPU classic and memory access mode based on options
+#
+(CPUClass, test_mem_mode, FutureClass) = Simulation.setCPUClass(options)
+CPUClass.clock = '2GHz'
+CPUClass.numThreads = numThreads;
+
+np = options.num_cpus
+print "Creating %d CPUs" % np
+print "Test mem mode is %s" % test_mem_mode
+
+#
+#  Create the system
+#
+system = System(cpu = [CPUClass(cpu_id=i) for i in xrange(np)],
+                membus = CoherentBus(), mem_mode = test_mem_mode)
+
+
+#
+#  Use SimpleMemory with ruby (protocol overrides to NVMainControl) and NVMainMemory for classic caches
+#
+if '--ruby' in sys.argv:
+    system.physmem = SimpleMemory(range=AddrRange("2048MB"))
+else:
+    system.physmem = NVMainMemory(range=AddrRange("2048MB"))
+
+options.use_map = True
+
+if options.ruby:
+    Ruby.create_system(options, system)
+    assert(options.num_cpus == len(system.ruby._cpu_ruby_ports))
+
+
+#
+#  Create the configuration overrides string for NVMain
+#
+nvmaincfg = ""
+nvmaincfgparams = ""
+nvmaincfgvalues = ""
+
+argnum = 1
+for arg in sys.argv:
+    if arg[:9] == "--nvmain_":
+        if nvmaincfgparams != "":
+            nvmaincfgparams += ","
+            nvmaincfgvalues += ","
+        nvmaincfgparams += arg[9:]
+        nvmaincfgvalues += sys.argv[argnum]
+
+        if arg == '--nvmain_config':
+            nvmaincfg = sys.argv[argnum]
+    argnum = argnum + 1
+
+
+#
+#  Pass the configuration overrides to NVMainControl or NVMainMemory depending on ruby/classic mode
+#
+if options.ruby:
+    for i in xrange(options.num_dirs):
+        exec("system.dir_cntrl%d.memBuffer.configparams = nvmaincfgparams" % i)
+        exec("system.dir_cntrl%d.memBuffer.configvalues = nvmaincfgvalues" % i)
+else:
+    system.physmem.config = nvmaincfg
+    system.physmem.configparams = nvmaincfgparams
+    system.physmem.configvalues = nvmaincfgvalues
+    system.physmem.cpu_frequency = CPUClass.clock
+
+
+
+#
+#  Assign comma delimited programs to each CPU
+#
+for i in xrange(np):
+    process = LiveProcess()
+    process.executable = options.cmd
+    process.cmd = [options.cmd] + options.options.split()
+
+    system.cpu[i].workload = process
+    print "CPU %d is running process %s" % (i, process.cmd)
+
+    system.cpu[i].createInterruptController()
+
+    if options.ruby:
+        system.cpu[i].icache_port = system.ruby._cpu_ruby_ports[i].slave
+        system.cpu[i].dcache_port = system.ruby._cpu_ruby_ports[i].slave
+
+if not options.ruby:
+    system.system_port = system.membus.slave
+    system.physmem.port = system.membus.master
+    CacheConfig.config_cache(options, system)
+
+
+root = Root(full_system = False, system = system)
+Simulation.run(options, root, system, FutureClass)
diff -r 1553e7995205 configs/example/nvmain_se.py
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/configs/example/nvmain_se.py	Fri Oct 12 16:01:36 2012 -0400
@@ -0,0 +1,250 @@
+# Copyright (c) 2006-2008 The Regents of The University of Michigan
+# All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions are
+# met: redistributions of source code must retain the above copyright
+# notice, this list of conditions and the following disclaimer;
+# redistributions in binary form must reproduce the above copyright
+# notice, this list of conditions and the following disclaimer in the
+# documentation and/or other materials provided with the distribution;
+# neither the name of the copyright holders nor the names of its
+# contributors may be used to endorse or promote products derived from
+# this software without specific prior written permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+#
+# Author: Matt Poremba
+
+
+import os
+import optparse
+import sys
+from os.path import join as joinpath
+
+import m5
+from m5.defines import buildEnv
+from m5.objects import *
+from m5.util import addToPath, fatal
+
+if buildEnv['FULL_SYSTEM']:
+    fatal("This script requires syscall emulation mode (*_SE).")
+
+addToPath('../common')
+addToPath('../ruby')
+addToPath('../topologies')
+
+import Options
+import Ruby
+import Simulation
+import CacheConfig
+from Caches import *
+from cpu2000 import *
+
+
+def get_processes(options):
+    """Interprets provided options and returns a list of processes"""
+
+    multiprocesses = []
+    inputs = []
+    outputs = []
+    errouts = []
+    pargs = []
+
+    workloads = options.cmd.split(';')
+    if options.input != "":
+        inputs = options.input.split(';')
+    if options.output != "":
+        outputs = options.output.split(';')
+    if options.errout != "":
+        errouts = options.errout.split(';')
+    if options.options != "":
+        pargs = options.options.split(';')
+
+    idx = 0
+    for wrkld in workloads:
+        process = LiveProcess()
+        process.executable = wrkld
+
+        if len(pargs) > idx:
+            process.cmd = [wrkld] + pargs[idx].split()
+        else:
+            process.cmd = [wrkld]
+
+        if len(inputs) > idx:
+            process.input = inputs[idx]
+        if len(outputs) > idx:
+            process.output = outputs[idx]
+        if len(errouts) > idx:
+            process.errout = errouts[idx]
+
+        multiprocesses.append(process)
+        idx += 1
+
+    if options.smt:
+        assert(options.cpu_type == "detailed" or options.cpu_type == "inorder")
+        return multiprocesses, idx
+    else:
+        return multiprocesses, 1
+
+# Get paths we might need.  It's expected this file is in m5/configs/example.
+config_path = os.path.dirname(os.path.abspath(__file__))
+config_root = os.path.dirname(config_path)
+m5_root = os.path.dirname(config_root)
+
+parser = optparse.OptionParser()
+Options.addCommonOptions(parser)
+Options.addSEOptions(parser)
+
+# Benchmark options
+parser.add_option("--nvmain_PARAM", type="string", default="NULL", help="Set NVMain configuration value for PARAM (e.g., --nvmain_RANKS 4, --nvmain_BANKS 8, etc.)");
+
+
+if '--ruby' in sys.argv:
+    Ruby.define_options(parser)
+
+argnum = 1
+for arg in sys.argv:
+    if arg[:9] == "--nvmain_":
+        parser.add_option(arg, type="string", default="NULL", help="Set NVMain configuration value for PARAM")
+    argnum = argnum + 1
+
+(options, args) = parser.parse_args()
+
+
+if args:
+    print "Error: script doesn't take any positional arguments"
+    sys.exit(1)
+
+multiprocesses = []
+numThreads = 1
+
+if options.bench:
+    apps = options.bench.split("-")
+    if len(apps) != options.num_cpus:
+        print "number of benchmarks not equal to set num_cpus!"
+        sys.exit(1)
+
+    for app in apps:
+        try:
+            if buildEnv['TARGET_ISA'] == 'alpha':
+                exec("workload = %s('alpha', 'tru64', 'ref')" % app)
+            else:
+                exec("workload = %s(buildEnv['TARGET_ISA'], 'linux', 'ref')" % app)
+            multiprocesses.append(workload.makeLiveProcess())
+        except:
+            print >>sys.stderr, "Unable to find workload for %s: %s" % (buildEnv['TARGET_ISA'], app)
+            sys.exit(1)
+elif options.cmd:
+    multiprocesses, numThreads = get_processes(options)
+else:
+    print >> sys.stderr, "No workload specified. Exiting!\n"
+    sys.exit(1)
+
+
+(CPUClass, test_mem_mode, FutureClass) = Simulation.setCPUClass(options)
+CPUClass.clock = options.clock
+CPUClass.numThreads = numThreads
+
+# Check -- do not allow SMT with multiple CPUs
+if options.smt and options.num_cpus > 1:
+    fatal("You cannot use SMT with multiple CPUs!")
+
+np = options.num_cpus
+system = System(cpu = [CPUClass(cpu_id=i) for i in xrange(np)],
+                physmem = NVMainMemory(range=AddrRange("512MB")),
+                membus = CoherentBus(), mem_mode = test_mem_mode)
+
+# Sanity check
+if options.fastmem and (options.caches or options.l2cache):
+    fatal("You cannot use fastmem in combination with caches!")
+
+
+nvmaincfgparams = ""
+nvmaincfgvalues = ""
+
+argnum = 1
+for arg in sys.argv:
+    if arg[:9] == "--nvmain_":
+        if nvmaincfgparams != "":
+            nvmaincfgparams += ","
+            nvmaincfgvalues += ","
+        nvmaincfgparams += arg[9:]
+        nvmaincfgvalues += sys.argv[argnum]
+
+        if arg == '--nvmain_config':
+            nvmaincfg = sys.argv[argnum]
+
+    argnum = argnum + 1
+
+
+if options.ruby:
+    for i in xrange(options.num_dirs):
+        exec("system.dir_cntrl%d.memBuffer.configparams = nvmaincfgparams" % i)
+        exec("system.dir_cntrl%d.memBuffer.configvalues = nvmaincfgvalues" % i)
+else:
+    system.physmem.config = nvmaincfg
+    system.physmem.configparams = nvmaincfgparams
+    system.physmem.configvalues = nvmaincfgvalues
+    system.physmem.cpu_frequency = CPUClass.clock
+
+
+
+for i in xrange(np):
+    if options.smt:
+        system.cpu[i].workload = multiprocesses
+    elif len(multiprocesses) == 1:
+        system.cpu[i].workload = multiprocesses[0]
+    else:
+        system.cpu[i].workload = multiprocesses[i]
+
+    if options.fastmem:
+        system.cpu[i].fastmem = True
+
+    if options.checker:
+        system.cpu[i].addCheckerCpu()
+
+if options.ruby:
+    if not (options.cpu_type == "detailed" or options.cpu_type == "timing"):
+        print >> sys.stderr, "Ruby requires TimingSimpleCPU or O3CPU!!"
+        sys.exit(1)
+
+    options.use_map = True
+    Ruby.create_system(options, system)
+    assert(options.num_cpus == len(system.ruby._cpu_ruby_ports))
+
+    for i in xrange(np):
+        ruby_port = system.ruby._cpu_ruby_ports[i]
+
+        # Create the interrupt controller and connect its ports to Ruby
+        # Note that the interrupt controller is always present but only
+        # in x86 does it have message ports that need to be connected
+        system.cpu[i].createInterruptController()
+
+        # Connect the cpu's cache ports to Ruby
+        system.cpu[i].icache_port = ruby_port.slave
+        system.cpu[i].dcache_port = ruby_port.slave
+        if buildEnv['TARGET_ISA'] == 'x86':
+            system.cpu[i].interrupts.pio = ruby_port.master
+            system.cpu[i].interrupts.int_master = ruby_port.slave
+            system.cpu[i].interrupts.int_slave = ruby_port.master
+            system.cpu[i].itb.walker.port = ruby_port.slave
+            system.cpu[i].dtb.walker.port = ruby_port.slave
+else:
+    system.system_port = system.membus.slave
+    system.physmem.port = system.membus.master
+    CacheConfig.config_cache(options, system)
+
+root = Root(full_system = False, system = system)
+Simulation.run(options, root, system, FutureClass)
+
diff -r 1553e7995205 configs/ruby/MESI_CMP_directory.py
--- a/configs/ruby/MESI_CMP_directory.py	Fri Oct 05 14:14:36 2012 -0400
+++ b/configs/ruby/MESI_CMP_directory.py	Fri Oct 12 16:01:36 2012 -0400
@@ -143,8 +143,13 @@
         # Create the Ruby objects associated with the directory controller
         #
 
-        mem_cntrl = RubyMemoryControl(version = i,
-                                      ruby_system = ruby_system)
+        try:
+            mem_cntrl = NVMMemoryControl(version = i,
+                                         config = options.nvmain_config,
+                                         physicalMem = system.physmem)
+        except:
+            mem_cntrl = RubyMemoryControl(version = i,
+                                          ruby_system = ruby_system)
 
         dir_size = MemorySize('0B')
         dir_size.value = mem_module_size
diff -r 1553e7995205 configs/spec2006/Mybench.py
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/configs/spec2006/Mybench.py	Fri Oct 12 16:01:36 2012 -0400
@@ -0,0 +1,353 @@
+#Mybench.py
+
+
+import os
+import optparse
+import sys
+from os import environ as env
+from os.path import join as joinpath
+
+import m5
+from m5.defines import buildEnv
+from m5.objects import *
+from m5.util import addToPath, fatal
+
+addToPath('../common')
+
+import Simulation
+import CacheConfig
+from Caches import *
+
+binary_dir = env.get('SPEC2006_PATH') + "/cpu2006/benchspec/CPU2006/bin/"
+data_dir = env.get('SPEC2006_PATH') + "/cpu2006/benchspec/CPU2006/"
+output_dir = env.get('SCRATCH_PATH') + "/specout/"
+
+
+#400.perlbench
+perlbench = LiveProcess()
+perlbench.executable =  binary_dir+'400.perlbench_base.alpha-gcc'
+data=data_dir+'400.perlbench/data/ref/input/checkspam.pl'
+lib=data_dir+'400.perlbench/data/all/input/lib'
+perlbench.cmd = [perlbench.executable] + ['-I'+lib, data]
+perlbench.output = output_dir+'perlbench_checkspam.out'
+
+#401.bzip2
+bzip2 = LiveProcess()
+bzip2.executable =  binary_dir+'401.bzip2_base.alpha-gcc'
+data=data_dir+'401.bzip2/data/all/input/input.program'
+bzip2.cmd = [bzip2.executable] + [data, '280']
+bzip2.output = output_dir+'bzip2_input.program.out'
+
+#403.gcc
+gcc = LiveProcess()
+gcc.executable =  binary_dir+'403.gcc_base.alpha-gcc'
+data=data_dir+'403.gcc/data/ref/input/200.i'
+output=output_dir+'gcc_403.gcc_200.s'
+gcc.cmd = [gcc.executable] + [data]+['-o',output]
+gcc.output = output_dir+'gcc_ccc.out'
+
+#410.bwaves
+bwaves = LiveProcess()
+bwaves.executable =  binary_dir+'410.bwaves_base.alpha-gcc'
+data=data_dir+'410.bwaves/data/ref/input/bwaves.in'
+bwaves.cwd = data_dir+'410.bwaves/data/ref/input/'
+bwaves.cmd = [bwaves.executable]+[data]
+
+#416.gamess
+gamess=LiveProcess()
+gamess.executable =  binary_dir+'416.gamess_base.alpha-gcc'
+gamess.cmd = [gamess.executable]
+data=data_dir+'416.gamess/data/ref/input/triazolium.config'
+gamess.cwd = data_dir+'416.gamess/run/build_base_i386-m32-gcc42-nn.0000/'
+gamess.input=data
+gamess.output=output_dir+'gamess_triazolium.output'
+
+#429.mcf
+mcf = LiveProcess()
+mcf.executable =  binary_dir+'429.mcf_base.alpha-gcc'
+data=data_dir+'429.mcf/data/ref/input/inp.in'
+mcf.cmd = [mcf.executable] + [data]
+mcf.output = output_dir+'mcf_inp.out'
+
+#433.milc
+milc=LiveProcess()
+milc.executable = binary_dir+'433.milc_base.alpha-gcc'
+stdin=data_dir+'433.milc/data/ref/input/su3imp.in'
+milc.cmd = [milc.executable]
+milc.input=stdin
+milc.output=output_dir+'milc_su3imp.out'
+
+#434.zeusmp
+zeusmp=LiveProcess()
+zeusmp.executable =  binary_dir+'434.zeusmp_base.alpha-gcc'
+zeusmp.cwd = data_dir+'434.zeusmp/data/ref/input/'
+zeusmp.cmd = [zeusmp.executable]
+zeusmp.output = output_dir+'zeusmp.stdout'
+
+#435.gromacs
+gromacs = LiveProcess()
+gromacs.executable =  binary_dir+'435.gromacs_base.alpha-gcc'
+data=data_dir+'435.gromacs/data/ref/input/gromacs.tpr'
+gromacs.cmd = [gromacs.executable] + ['-silent','-deffnm',data,'-nice','0']
+
+#436.cactusADM
+cactusADM = LiveProcess()
+cactusADM.executable =  binary_dir+'436.cactusADM_base.alpha-gcc'
+data=data_dir+'436.cactusADM/data/ref/input/benchADM.par'
+cactusADM.cmd = [cactusADM.executable] + [data]
+cactusADM.output = output_dir+'cactusADM_benchADM.out'
+
+#437.leslie3d
+leslie3d=LiveProcess()
+leslie3d.executable =  binary_dir+'437.leslie3d_base.alpha-gcc'
+stdin=data_dir+'437.leslie3d/data/ref/input/leslie3d.in'
+leslie3d.cmd = [leslie3d.executable]
+leslie3d.input=stdin
+leslie3d.output=output_dir+'leslie3d_leslie3d.stdout'
+
+#444.namd
+namd = LiveProcess()
+namd.executable =  binary_dir+'444.namd_base.alpha-gcc'
+input=data_dir+'444.namd/data/all/input/namd.input'
+namd.cmd = [namd.executable] + ['--input',input,'--iterations','38','--output','namd.out']
+namd.output=output_dir+'namd_namd.stdout'
+
+#445.gobmk
+gobmk=LiveProcess()
+gobmk.executable =  binary_dir+'445.gobmk_base.alpha-gcc'
+stdin=data_dir+'445.gobmk/data/ref/input/nngs.tst'
+gobmk.cwd = data_dir+'data/all/input/'
+gobmk.cmd = [gobmk.executable]+['--quiet','--mode','gtp']
+gobmk.input=stdin
+gobmk.output=output_dir+'gobmk_nngs.out'
+
+#447.dealII
+dealII=LiveProcess()
+dealII.executable =  binary_dir+'447.dealII_base.alpha-gcc'
+dealII.cmd = [gobmk.executable]+['23']
+dealII.output=output_dir+'dealII_log'
+
+
+#450.soplex
+soplex=LiveProcess()
+soplex.executable =  binary_dir+'450.soplex_base.alpha-gcc'
+data=data_dir+'450.soplex/data/ref/input/pds-50.mps'
+soplex.cmd = [soplex.executable]+['-s1','-e','-m45000',data]
+soplex.output = output_dir+'soplex_pds-50.out'
+
+#453.povray
+povray=LiveProcess()
+povray.executable =  binary_dir+'453.povray_base.alpha-gcc'
+data=data_dir+'453.povray/data/ref/input/SPEC-benchmark-ref.ini'
+povray.cwd = data_dir+'453.povray/data/all/input/'
+povray.cmd = [povray.executable]+[data]
+povray.output = output_dir+'povray_SPEC-benchmark-ref.stdout'
+
+#454.calculix
+calculix=LiveProcess()
+calculix.executable =  binary_dir+'454.calculix_base.alpha-gcc'
+data=data_dir+'454.calculix/data/ref/input/hyperviscoplastic.inp'
+calculix.cmd = [calculix.executable]+['-i',data]
+calculix.output = output_dir+'calculix_ref.log'
+
+#456.hmmer
+hmmer=LiveProcess()
+hmmer.executable =  binary_dir+'456.hmmer_base.alpha-gcc'
+data=data_dir+'456.hmmer/data/ref/input/retro.hmm'
+hmmer.cmd = [hmmer.executable]+['--fixed', '0', '--mean', '500', '--num', '500000', '--sd', '350', '--seed', '0', data]
+hmmer.output = output_dir+'hmmer_retro.out'
+
+#458.sjeng
+sjeng=LiveProcess()
+sjeng.executable =  binary_dir+'458.sjeng_base.alpha-gcc'
+data=data_dir+'458.sjeng/data/ref/input/ref.txt'
+sjeng.cmd = [sjeng.executable]+[data]
+sjeng.output = output_dir+'sjeng_ref.out'
+
+#459.GemsFDTD
+GemsFDTD=LiveProcess()
+GemsFDTD.executable =  binary_dir+'459.GemsFDTD_base.alpha-gcc'
+GemsFDTD.cwd = data_dir+'459.GemsFDTD/data/ref/input/'
+GemsFDTD.cmd = [GemsFDTD.executable]
+GemsFDTD.output = output_dir+'GemsFDTD_ref.log'
+
+#462.libquantum
+libquantum=LiveProcess()
+libquantum.executable =  binary_dir+'462.libquantum_base.alpha-gcc'
+libquantum.cmd = [libquantum.executable]+['1397','8']
+libquantum.output = output_dir+'libquantum_ref.out'
+
+#464.h264ref
+h264ref=LiveProcess()
+h264ref.executable =  binary_dir+'464.h264ref_base.alpha-gcc'
+data=data_dir+'464.h264ref/data/ref/input/foreman_ref_encoder_baseline.cfg'
+h264ref.cwd = data_dir+'464.h264ref/data/all/input/'
+h264ref.cmd = [h264ref.executable]+['-d',data]
+h264ref.output = output_dir+'h264ref_foreman_ref_encoder_baseline.out'
+
+#465.tonto
+tonto=LiveProcess()
+tonto.executable = binary_dir+'465.tonto_base.alpha-gcc'
+tonto.cwd = data_dir+'465.tonto/data/ref/input/'
+tonto.cmd = [tonto.executable]
+tonto.output = output_dir+'tonto_ref.out'
+
+#470.lbm
+lbm=LiveProcess()
+lbm.executable =  binary_dir+'470.lbm_base.alpha-gcc'
+data=data_dir+'470.lbm/data/ref/input/100_100_130_ldc.of'
+lbm.cmd = [lbm.executable]+['3000', 'reference.dat', '0', '0' ,data]
+lbm.output = output_dir+'lbm_ref.out'
+
+#471.omnetpp
+omnetpp=LiveProcess()
+omnetpp.executable =  binary_dir+'471.omnetpp_base.alpha-gcc'
+data=data_dir+'471.omnetpp/data/ref/input/omnetpp.ini'
+omnetpp.cwd = data_dir+'471.omnetpp/data/ref/input/'
+omnetpp.cmd = [omnetpp.executable]+[data]
+omnetpp.output = output_dir+'omnetpp_omnetpp.log'
+
+#473.astar
+astar=LiveProcess()
+astar.executable =  binary_dir+'473.astar_base.alpha-gcc'
+data=data_dir+'473.astar/data/ref/input/BigLakes2048.cfg'
+astar.cwd = data_dir+'473.astar/data/ref/input'
+astar.cmd = [astar.executable]+[data]
+astar.output = output_dir+'astar_lake.out'
+
+#481.wrf
+wrf=LiveProcess()
+wrf.executable =  binary_dir+'481.wrf_base.alpha-gcc'
+data=data_dir+'481.wrf/data/ref/input/namelist.input'
+wrf.cmd = [wrf.executable]+[data]
+wrf.output = output_dir+'wrf_rsl.out.0000'
+
+#482.sphinx
+sphinx3=LiveProcess()
+sphinx3.executable =  binary_dir+'482.sphinx_livepretend_base.alpha-gcc'
+data=data_dir+'482.sphinx3/data/all/input/args.an4'
+ctlfile=data_dir+'482.sphinx3/data/all/input/model/lm/an4/an4.ctl'
+sphinx3.cwd = data_dir+'482.sphinx3/data/all/input/'
+sphinx3.cmd = [sphinx3.executable]+[ctlfile, '.', data]
+sphinx3.output = output_dir+'sphinx_an4.out'
+
+#483.xalancbmk
+xalancbmk=LiveProcess()
+xalancbmk.executable =  binary_dir+'483.Xalan_base.alpha-gcc'
+data=data_dir+'483.xalancbmk/data/ref/input/'
+xalancbmk.cmd = [xalancbmk.executable]+['-v',data+'t5.xml',data+'xalanc.xsl']
+xalancbmk.output = output_dir+'xalancbmk_ref.out'
+
+#998.specrand
+specrand_i=LiveProcess()
+specrand_i.executable = binary_dir+'998.specrand_base.alpha-gcc'
+specrand_i.cmd = [specrand_i.executable] + ['324342','24239']
+specrand_i.output = output_dir+'specrand_i_rand.24239.out'
+
+#999.specrand
+specrand_f=LiveProcess()
+specrand_f.executable = binary_dir+'999.specrand_base.alpha-gcc'
+specrand_f.cmd = [specrand_i.executable] + ['324342','24239']
+specrand_f.output = output_dir+'specrand_f_rand.24239.out'
+
+
+def get_spec_process(bench):
+    if bench == 'perlbench':
+        return perlbench
+    elif bench == 'bzip2':
+        return bzip2
+    elif bench == 'gcc':
+        return gcc
+    elif bench == 'bwaves':
+        return bwaves
+    elif bench == 'gamess':
+        return gamess
+    elif bench == 'mcf':
+        return mcf
+    elif bench == 'milc':
+        return milc
+    elif bench == 'zeusmp':
+        return zeusmp
+    elif bench == 'gromacs':
+        return gromacs
+    elif bench == 'cactusADM':
+        return cactusADM
+    elif bench == 'leslie3d':
+        return leslie3d
+    elif bench == 'namd':
+        return namd
+    elif bench == 'gobmk':
+        return gobmk
+    elif bench == 'dealII':
+        return dealII
+    elif bench == 'soplex':
+        return soplex
+    elif bench == 'povray':
+        return povray
+    elif bench == 'calculix':
+        return calculix
+    elif bench == 'hmmer':
+        return hmmer
+    elif bench == 'sjeng':
+        return sjeng
+    elif bench == 'GemsFDTD':
+        return GemsFDTD
+    elif bench == 'libquantum':
+        return libquantum
+    elif bench == 'h264ref':
+        return h264ref
+    elif bench == 'lbm':
+        return lbm
+    elif bench == 'omnetpp':
+        return omnetpp
+    elif bench == 'astar':
+        return astar
+    elif bench == 'tonto':
+        return tonto
+    elif bench == 'wrf':
+        return wrf
+    elif bench == 'sphinx3':
+        return sphinx3
+    elif bench == 'xalancbmk':
+        return xalancbmk
+    elif bench == 'specrand_i':
+        return specrand_i
+    elif bench == 'specrand_f':
+        return specrand_f
+    else:
+        print >> sys.stderr, "Unknown benchmark: '%s'!" % bench
+        print >> sys.stderr, "Choices are:"
+
+        print >> sys.stderr, "astar"
+        print >> sys.stderr, "bwaves"
+        print >> sys.stderr, "bzip2"
+        print >> sys.stderr, "cactusADM"
+        print >> sys.stderr, "calculix"
+        print >> sys.stderr, "dealII"
+        print >> sys.stderr, "gamess"
+        print >> sys.stderr, "gcc"
+        print >> sys.stderr, "GemsFDTD"
+        print >> sys.stderr, "gobmk"
+        print >> sys.stderr, "gromacs"
+        print >> sys.stderr, "h264ref"
+        print >> sys.stderr, "hmmer"
+        print >> sys.stderr, "lbm"
+        print >> sys.stderr, "leslie3d"
+        print >> sys.stderr, "libquantum"
+        print >> sys.stderr, "mcf"
+        print >> sys.stderr, "milc"
+        print >> sys.stderr, "namd"
+        print >> sys.stderr, "omnetpp"
+        print >> sys.stderr, "perlbench"
+        print >> sys.stderr, "povray"
+        print >> sys.stderr, "sjeng"
+        print >> sys.stderr, "soplex"
+        print >> sys.stderr, "specrand_f"
+        print >> sys.stderr, "specrand_i"
+        print >> sys.stderr, "sphinx3"
+        print >> sys.stderr, "tonto"
+        print >> sys.stderr, "wrf"
+        print >> sys.stderr, "xalancbmk"
+        print >> sys.stderr, "zeusmp"
+        sys.exit(1)
+
diff -r 1553e7995205 configs/spec2006/classic.py
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/configs/spec2006/classic.py	Fri Oct 12 16:01:36 2012 -0400
@@ -0,0 +1,156 @@
+# Copyright (c) 2006-2008 The Regents of The University of Michigan
+# All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions are
+# met: redistributions of source code must retain the above copyright
+# notice, this list of conditions and the following disclaimer;
+# redistributions in binary form must reproduce the above copyright
+# notice, this list of conditions and the following disclaimer in the
+# documentation and/or other materials provided with the distribution;
+# neither the name of the copyright holders nor the names of its
+# contributors may be used to endorse or promote products derived from
+# this software without specific prior written permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+#
+# Author: Matt Poremba
+
+
+import os
+import optparse
+import sys
+from os.path import join as joinpath
+
+import m5
+from m5.defines import buildEnv
+from m5.objects import *
+from m5.util import addToPath, fatal
+
+if buildEnv['FULL_SYSTEM']:
+    fatal("This script requires syscall emulation mode (*_SE).")
+
+addToPath('../common')
+addToPath('../spec2006')
+addToPath('../topologies')
+
+import Options
+import Simulation
+import CacheConfig
+from Caches import *
+from cpu2000 import *
+from Mybench import *
+
+
+
+# Get paths we might need.  It's expected this file is in m5/configs/example.
+config_path = os.path.dirname(os.path.abspath(__file__))
+config_root = os.path.dirname(config_path)
+m5_root = os.path.dirname(config_root)
+
+parser = optparse.OptionParser()
+Options.addCommonOptions(parser)
+
+# Benchmark options
+parser.add_option("--stdout", action="store_true", help="Print benchmark output to stdout instead of a file.")
+parser.add_option("--nvmain_PARAM", type="string", default="NULL", help="Set NVMain configuration value for PARAM (e.g., --nvmain_RANKS 4, --nvmain_BANKS 8, etc.)");
+parser.add_option("--nvmain_atomic", action="store_true", help="Use NVMain also when in atomic mode (default is flat latency+variance)")
+parser.add_option("--atomic_latency", type="int", help="Use NVMain also when in atomic mode (default is flat latency+variance)")
+parser.add_option("--atomic_variance", type="int", help="Use NVMain also when in atomic mode (default is flat latency+variance)")
+parser.add_option("--no_nvmain", action="store_true", help="Don't use NVMain, use SimpleMemory")
+
+argnum = 1
+for arg in sys.argv:
+    if arg[:9] == "--nvmain_":
+        parser.add_option(arg, type="string", default="NULL", help="Set NVMain configuration value for PARAM")
+    argnum = argnum + 1
+
+execfile(os.path.join(config_root, "common", "Options.py"))
+
+(options, args) = parser.parse_args()
+
+if not args:
+    print "Error: No benchmarks specified to run!"
+    get_spec_process("") # pass nothing. get error.
+    sys.exit(1)
+
+
+nvmaincfg = ""
+nvmaincfgparams = ""
+nvmaincfgvalues = ""
+
+argnum = 1
+for arg in sys.argv:
+    if arg[:9] == "--nvmain_":
+        if nvmaincfgparams != "":
+            nvmaincfgparams += ","
+            nvmaincfgvalues += ","
+        nvmaincfgparams += arg[9:]
+        nvmaincfgvalues += sys.argv[argnum]
+
+        if arg == '--nvmain_config':
+            nvmaincfg = sys.argv[argnum]
+
+    argnum = argnum + 1
+
+
+numThreads = 1
+
+
+(CPUClass, test_mem_mode, FutureClass) = Simulation.setCPUClass(options)
+CPUClass.clock = '2GHz'
+CPUClass.numThreads = numThreads;
+
+np = options.num_cpus
+if len(args) != np:
+    print "Warning: Different number of benchmarks and CPUs. Increasing CPU count to %d" % len(args)
+    np = len(args)
+    options.num_cpus = np
+print "Creating %d CPUs" % np
+
+
+system = System(cpu = [CPUClass(cpu_id=i) for i in xrange(np)],
+                membus = CoherentBus(), mem_mode = test_mem_mode)
+
+options.use_map = True
+
+
+if options.no_nvmain:
+    system.physmem = SimpleMemory(range=AddrRange("2048MB"))
+else:
+    system.physmem = NVMainMemory(range=AddrRange("2048MB"))
+    system.physmem.config = nvmaincfg
+    system.physmem.configparams = nvmaincfgparams
+    system.physmem.configvalues = nvmaincfgvalues
+    system.physmem.atomic_mode = options.nvmain_atomic
+    system.physmem.cpu_frequency = CPUClass.clock
+
+
+spec_benchmarks = args
+for i in xrange(np):
+    spec_process = get_spec_process(spec_benchmarks[i])
+    if options.stdout:
+        spec_process.output = "cout"
+    system.cpu[i].workload = spec_process
+    print "CPU %d is running process %s" % (i, get_spec_process(spec_benchmarks[i]).cmd)
+
+    system.cpu[i].createInterruptController()
+
+
+system.system_port = system.membus.slave
+system.physmem.port = system.membus.master
+CacheConfig.config_cache(options, system)
+
+root = Root(full_system = False, system = system)
+
+Simulation.run(options, root, system, FutureClass)
diff -r 1553e7995205 configs/spec2006/spec2006.py
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/configs/spec2006/spec2006.py	Fri Oct 12 16:01:36 2012 -0400
@@ -0,0 +1,153 @@
+# Copyright (c) 2006-2008 The Regents of The University of Michigan
+# All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions are
+# met: redistributions of source code must retain the above copyright
+# notice, this list of conditions and the following disclaimer;
+# redistributions in binary form must reproduce the above copyright
+# notice, this list of conditions and the following disclaimer in the
+# documentation and/or other materials provided with the distribution;
+# neither the name of the copyright holders nor the names of its
+# contributors may be used to endorse or promote products derived from
+# this software without specific prior written permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+#
+# Author: Matt Poremba
+
+
+import os
+import optparse
+import sys
+from os.path import join as joinpath
+
+import m5
+from m5.defines import buildEnv
+from m5.objects import *
+from m5.util import addToPath, fatal
+
+if buildEnv['FULL_SYSTEM']:
+    fatal("This script requires syscall emulation mode (*_SE).")
+
+addToPath('../common')
+addToPath('../ruby')
+addToPath('../spec2006')
+addToPath('../topologies')
+
+import Options
+import Ruby
+import Simulation
+import CacheConfig
+from Caches import *
+from cpu2000 import *
+from Mybench import *
+
+
+
+# Get paths we might need.  It's expected this file is in m5/configs/example.
+config_path = os.path.dirname(os.path.abspath(__file__))
+config_root = os.path.dirname(config_path)
+m5_root = os.path.dirname(config_root)
+
+parser = optparse.OptionParser()
+Options.addCommonOptions(parser)
+
+# Benchmark options
+parser.add_option("--stdout", action="store_true", help="Print benchmark output to stdout instead of a file.")
+
+argnum = 1
+for arg in sys.argv:
+    if arg[:9] == "--nvmain_":
+        parser.add_option(arg, type="string", default="NULL", help="Set NVMain configuration value for PARAM")
+    argnum = argnum + 1
+
+execfile(os.path.join(config_root, "common", "Options.py"))
+
+Ruby.define_options(parser)
+
+(options, args) = parser.parse_args()
+
+if not args:
+    print "Error: No benchmarks specified to run!"
+    get_spec_process("") # pass nothing. get error.
+    sys.exit(1)
+
+
+nvmaincfgparams = ""
+nvmaincfgvalues = ""
+
+argnum = 1
+for arg in sys.argv:
+    if arg[:9] == "--nvmain_":
+        if nvmaincfgparams != "":
+            nvmaincfgparams += ","
+            nvmaincfgvalues += ","
+        nvmaincfgparams += arg[9:]
+        nvmaincfgvalues += sys.argv[argnum]
+    argnum = argnum + 1
+
+
+numThreads = 1
+
+
+(CPUClass, test_mem_mode, FutureClass) = Simulation.setCPUClass(options)
+CPUClass.clock = '2GHz'
+CPUClass.numThreads = numThreads;
+
+CPUClass.clock = '2GHz'
+CPUClass.numThreads = numThreads;
+
+np = options.num_cpus
+if len(args) != np:
+    print "Warning: Different number of benchmarks and CPUs. Increasing CPU count to %d" % len(args)
+    np = len(args)
+    options.num_cpus = np
+print "Creating %d CPUs" % np
+
+
+system = System(cpu = [CPUClass(cpu_id=i) for i in xrange(np)],
+                physmem = SimpleMemory(range=AddrRange("2048MB")),
+                membus = CoherentBus(), mem_mode = test_mem_mode)
+
+options.use_map = True
+Ruby.create_system(options, system)
+print "Creating ruby system"
+assert(options.num_cpus == len(system.ruby._cpu_ruby_ports))
+
+
+for i in xrange(options.num_dirs):
+    exec("system.dir_cntrl%d.memBuffer.configparams = nvmaincfgparams" % i)
+    exec("system.dir_cntrl%d.memBuffer.configvalues = nvmaincfgvalues" % i)
+
+
+spec_benchmarks = args
+for i in xrange(np):
+    spec_process = get_spec_process(spec_benchmarks[i])
+    if options.stdout:
+        spec_process.output = "cout"
+    system.cpu[i].workload = spec_process
+    print "CPU %d is running process %s" % (i, get_spec_process(spec_benchmarks[i]).cmd)
+
+    system.cpu[i].icache_port = system.ruby._cpu_ruby_ports[i].slave
+    system.cpu[i].dcache_port = system.ruby._cpu_ruby_ports[i].slave
+
+    system.cpu[i].createInterruptController()
+
+    # not sure what this is, enable at your own risk.
+    if options.fastmem:
+        system.cpu[0].physmem_port = system.physmem.port
+
+root = Root(full_system = False, system = system)
+
+Simulation.run(options, root, system, FutureClass)
diff -r 1553e7995205 src/mem/NVMainMemory.py
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/mem/NVMainMemory.py	Fri Oct 12 16:01:36 2012 -0400
@@ -0,0 +1,42 @@
+# Copyright (c) 2009 Advanced Micro Devices, Inc.
+# All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions are
+# met: redistributions of source code must retain the above copyright
+# notice, this list of conditions and the following disclaimer;
+# redistributions in binary form must reproduce the above copyright
+# notice, this list of conditions and the following disclaimer in the
+# documentation and/or other materials provided with the distribution;
+# neither the name of the copyright holders nor the names of its
+# contributors may be used to endorse or promote products derived from
+# this software without specific prior written permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+#
+
+from m5.params import *
+from AbstractMemory import *
+
+
+class NVMainMemory(AbstractMemory):
+    type = 'NVMainMemory'
+    port = SlavePort("Slave ports")
+    atomic_mode = Param.Bool(False, "Enable to use NVMain in atomic mode rather than latency/variance")
+    atomic_latency = Param.Latency('30ns', "Request latency in atomic mode")
+    atomic_variance = Param.Latency('30ns', "Request latency in atomic mode")
+    cpu_frequency = Param.Clock('1t', "Frequency of CPU")
+
+    config = Param.String("NULL", "")
+    configparams = Param.String("", "")
+    configvalues = Param.String("", "")
diff -r 1553e7995205 src/mem/SConscript
--- a/src/mem/SConscript	Fri Oct 05 14:14:36 2012 -0400
+++ b/src/mem/SConscript	Fri Oct 12 16:01:36 2012 -0400
@@ -56,8 +56,10 @@
     SimObject('AbstractMemory.py')
     SimObject('SimpleMemory.py')
     SimObject('SimpleDRAM.py')
+    SimObject('NVMainMemory.py')
     Source('abstract_mem.cc')
     Source('simple_mem.cc')
+    Source('nvmain_mem.cc')
     Source('page_table.cc')
     Source('physical.cc')
     Source('simple_dram.cc')
@@ -77,6 +79,7 @@
 DebugFlag('MMU')
 DebugFlag('MemoryAccess')
 DebugFlag('PacketQueue')
+DebugFlag('NVMain')
 
 DebugFlag('ProtocolTrace')
 DebugFlag('RubyCache')
diff -r 1553e7995205 src/mem/nvmain_mem.cc
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/mem/nvmain_mem.cc	Fri Oct 12 16:01:36 2012 -0400
@@ -0,0 +1,420 @@
+/*
+ * Copyright (c) 1999-2008 Mark D. Hill and David A. Wood
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met: redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer;
+ * redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution;
+ * neither the name of the copyright holders nor the names of its
+ * contributors may be used to endorse or promote products derived from
+ * this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/*
+ *  This file is part of NVMain- A cycle accurate timing, bit-accurate
+ *  energy simulator for non-volatile memory. Originally developed by
+ *  Matt Poremba at the Pennsylvania State University.
+ *
+ *  Website: http://www.cse.psu.edu/~poremba/nvmain/
+ *  Email: mrp5060@psu.edu
+ *
+ *  ---------------------------------------------------------------------
+ *
+ *  If you use this software for publishable research, please include
+ *  the original NVMain paper in the citation list and mention the use
+ *  of NVMain.
+ *
+ */
+
+#include "SimInterface/Gem5Interface/Gem5Interface.h"
+#include "base/random.hh"
+#include "mem/nvmain_mem.hh"
+#include "debug/NVMain.hh"
+
+using namespace NVM;
+
+
+void breakGDB() { }
+
+
+NVMainMemory::NVMainMemory(const Params *p)
+    : AbstractMemory(p), port(name() + ".port", *this), clock(p->cpu_frequency),
+      lat(p->atomic_latency), lat_var(p->atomic_variance),
+      nvmain_atomic(p->atomic_mode)
+{
+    char *cfgparams;
+    char *cfgvalues;
+    char *cparam, *cvalue;
+
+    char *saveptr1, *saveptr2;
+
+    m_nvmainPtr = NULL;
+    m_slot_available = true;
+    m_nacked_requests = false;
+
+    m_nvmainConfigPath = p->config;
+
+    m_nvmainConfig = new Config( );
+
+    m_nvmainConfig->Read( m_nvmainConfigPath );
+    std::cout << "NVMainControl: Reading NVMain config file: " << m_nvmainConfigPath << "." << std::endl;
+
+    m_avgAtomicLatency = 100.0f;
+    m_numAtomicAccesses = 0;
+
+    for( cfgparams = (char *)p->configparams.c_str(), cfgvalues = (char *)p->configvalues.c_str()
+         ; ; cfgparams = NULL, cfgvalues = NULL )
+    {
+        cparam = strtok_r( cfgparams, ",", &saveptr1 );
+        cvalue = strtok_r( cfgvalues, ",", &saveptr2 );
+
+        if( cparam == NULL || cvalue == NULL )
+            break;
+
+        std::cout << "NVMain: Overriding parameter `" << cparam << "' with `" << cvalue << "'" << std::endl;
+
+        m_nvmainConfig->SetValue( cparam, cvalue );
+    }
+
+   eventManager = new NVMainMemoryEventManager(&mainEventQueue, *this);
+
+   BusWidth = m_nvmainConfig->GetValue( "BusWidth" );
+   tBURST = m_nvmainConfig->GetValue( "tBURST" );
+   RATE = m_nvmainConfig->GetValue( "RATE" );
+
+   lastWakeup = curTick();
+}
+
+
+void
+NVMainMemory::init()
+{
+    m_nvmainPtr = new NVMain( );
+    m_nvmainSimInterface = new Gem5Interface( );
+
+    m_nvmainConfig->SetSimInterface( m_nvmainSimInterface );
+
+    m_nvmainPtr->SetConfig( m_nvmainConfig );
+
+    if (port.isConnected()) {
+        port.sendRangeChange();
+    }
+
+    eventManager->scheduleWakeup( );
+
+    AddChild( m_nvmainPtr );
+    m_nvmainPtr->SetParent( this );
+}
+
+
+SlavePort &
+NVMainMemory::getSlavePort(const std::string& if_name, int idx)
+{
+    if (if_name != "port") {
+        return MemObject::getSlavePort(if_name, idx);
+    } else {
+        return port;
+    }
+}
+
+
+NVMainMemory::MemoryPort::MemoryPort(const std::string& _name, NVMainMemory& _memory)
+    : SimpleTimingPort(_name, &_memory), memory(_memory)
+{
+
+}
+
+
+AddrRangeList NVMainMemory::MemoryPort::getAddrRanges() const
+{
+    AddrRangeList ranges;
+    ranges.push_back(memory.getAddrRange());
+    return ranges;
+}
+
+
+Tick
+NVMainMemory::MemoryPort::recvAtomic(PacketPtr pkt)
+{
+    if (pkt->memInhibitAsserted())
+        return 0;
+
+    /*
+     *  Don't use NVMain in atomic mode (faster). Use simple memory method
+     */
+    if (!memory.nvmain_atomic) {
+        Tick latency = memory.lat;
+
+        if (memory.lat_var != 0)
+            latency += random_mt.random<Tick>(0, memory.lat_var);
+
+        memory.access(pkt);
+
+        return latency;
+    }
+
+    if (!pkt->isRead() && !pkt->isWrite()) {
+        std::cout << "NVMainMemory: Received a packet that is neither read nor write" << std::endl;
+
+        return memory.doAtomicAccess(pkt);
+    }
+
+    /*
+     *  Send the atomic request to NVMain in case there is a cache that needs warm up
+     */
+    /*
+    NVMainRequest *request = new NVMainRequest( );
+
+    unsigned int transfer_size;
+    uint8_t *hostAddr;
+
+    transfer_size =  memory.BusWidth / 8;
+    transfer_size *= memory.tBURST * memory.RATE;
+
+    if (pkt->isRead())
+    {
+        Request *dataReq = new Request(pkt->req->getPaddr(), transfer_size, 0, Request::funcMasterId);
+        Packet *dataPkt = new Packet(dataReq, MemCmd::ReadReq);
+        dataPkt->allocate();
+        memory.doFunctionalAccess(dataPkt);
+
+        hostAddr = new uint8_t[ dataPkt->getSize() ];
+        memcpy( hostAddr, dataPkt->getPtr<uint8_t>(), dataPkt->getSize() );
+
+        delete dataPkt;
+        delete dataReq;
+    }
+    else
+    {
+        hostAddr = new uint8_t[ pkt->getSize() ];
+
+        memcpy( hostAddr, pkt->getPtr<uint8_t>(), pkt->getSize() );
+    }
+
+    for(int i = 0; i < transfer_size; i++ )
+    {
+        request->data.SetByte(i, *(hostAddr + (transfer_size - 1) - i));
+    }
+    delete [] hostAddr;
+
+    request->access = UNKNOWN_ACCESS;
+    request->address.SetPhysicalAddress(pkt->req->getPaddr());
+    request->status = MEM_REQUEST_INCOMPLETE;
+    request->type = (pkt->isRead()) ? READ : WRITE;
+    request->owner = (NVMObject *)&memory;
+
+    request->programCounter = pkt->req->_pc;
+    request->threadId = pkt->req->_contextId;
+
+    memory.m_nvmainPtr->AtomicRequest(request);
+    */
+    return memory.doAtomicAccess(pkt);
+}
+
+
+void
+NVMainMemory::MemoryPort::recvFunctional(PacketPtr pkt)
+{
+    pkt->pushLabel(memory.name());
+
+    if (!queue.checkFunctional(pkt)) {
+        memory.doFunctionalAccess(pkt);
+    }
+
+    pkt->popLabel();
+}
+
+
+bool
+NVMainMemory::MemoryPort::recvTimingReq(PacketPtr pkt)
+{
+    if (pkt->memInhibitAsserted()) {
+        delete pkt;
+        return true;
+    }
+
+
+    if (!pkt->isRead() && !pkt->isWrite()) {
+        std::cout << "NVMainMemory: Received a packet that is neither read nor write" << std::endl;
+
+        memory.doAtomicAccess(pkt);
+        queue.schedSendTiming(pkt, curTick() + 1);
+
+        return true;
+    }
+
+    NVMainRequest *request = new NVMainRequest( );
+
+    bool enqueued;
+    unsigned int transfer_size;
+    uint8_t *hostAddr;
+
+    transfer_size =  memory.BusWidth / 8;
+    transfer_size *= memory.tBURST * memory.RATE;
+
+    if (pkt->isRead())
+    {
+        Request *dataReq = new Request(pkt->req->getPaddr(), transfer_size, 0, Request::funcMasterId);
+        Packet *dataPkt = new Packet(dataReq, MemCmd::ReadReq);
+        dataPkt->allocate();
+        memory.doFunctionalAccess(dataPkt);
+
+        hostAddr = new uint8_t[ dataPkt->getSize() ];
+        memcpy( hostAddr, dataPkt->getPtr<uint8_t>(), dataPkt->getSize() );
+
+        delete dataPkt;
+        delete dataReq;
+    }
+    else
+    {
+        hostAddr = new uint8_t[ pkt->getSize() ];
+
+        memcpy( hostAddr, pkt->getPtr<uint8_t>(), pkt->getSize() );
+    }
+
+    for(int i = 0; i < transfer_size; i++ )
+    {
+        request->data.SetByte(i, *(hostAddr + (transfer_size - 1) - i));
+    }
+    delete [] hostAddr;
+
+    request->access = UNKNOWN_ACCESS;
+    request->address.SetPhysicalAddress(pkt->req->getPaddr());
+    request->status = MEM_REQUEST_INCOMPLETE;
+    request->type = (pkt->isRead()) ? READ : WRITE;
+    request->owner = (NVMObject *)&memory;
+
+    if(pkt->req->hasPC()) request->programCounter = pkt->req->getPC();
+    if(pkt->req->hasContextId()) request->threadId = pkt->req->contextId();
+
+    enqueued = memory.m_nvmainPtr->NewRequest(request);
+    if(enqueued)
+    {
+        memory.m_slot_available = true;
+
+        NVMainMemoryRequest *memRequest = new NVMainMemoryRequest;
+
+        memRequest->request = request;
+        memRequest->packet = pkt;
+        memRequest->issueTick = curTick();
+        memRequest->atomic = false;
+
+        DPRINTF(NVMain, "nvmain_mem.cc: Enqueued Mem request for 0x%x of type %s\n", request->address.GetPhysicalAddress( ), ((pkt->isRead()) ? "READ" : "WRITE") );
+
+        memory.m_request_map.insert( std::pair<NVMainRequest *, NVMainMemoryRequest *>( request, memRequest ) );
+    }
+    else
+    {
+        memory.m_slot_available = false;
+    }
+
+    //memory.Sync();
+
+    return enqueued;
+}
+
+
+
+Tick NVMainMemory::doAtomicAccess(PacketPtr pkt)
+{
+    access(pkt);
+    return static_cast<Tick>(m_avgAtomicLatency);
+}
+
+
+
+void NVMainMemory::doFunctionalAccess(PacketPtr pkt)
+{
+    functionalAccess(pkt);
+}
+
+
+void NVMainMemory::NVMainMemoryEvent::process()
+{
+    // Cycle memory controller
+    memory.m_nvmainPtr->Cycle( );
+
+    memory.eventManager->scheduleWakeup( );
+}
+
+
+bool NVMainMemory::RequestComplete(NVM::NVMainRequest *req)
+{
+
+    NVMainMemoryRequest *memRequest;
+    std::map<NVMainRequest *, NVMainMemoryRequest *>::iterator iter;
+
+    // Find the mem request pointer in the map.
+    assert(m_request_map.count(req) != 0);
+    iter = m_request_map.find(req);
+    memRequest = iter->second;
+
+    DPRINTF(NVMain, "Completed Mem request for 0x%x of type %s\n", req->address.GetPhysicalAddress( ), ((memRequest->packet->isRead()) ? "READ" : "WRITE"));
+
+    if(!memRequest->atomic)
+    {
+        bool respond = memRequest->packet->needsResponse();
+        access(memRequest->packet);
+
+        if(respond)
+        {
+            port.queue.schedSendTiming(memRequest->packet, curTick() + 1);
+
+            delete req;
+            delete memRequest;
+        }
+        else
+        {
+            delete memRequest->packet;
+            delete req;
+            delete memRequest;
+        }
+    }
+    else
+    {
+        delete req;
+        delete memRequest;
+    }
+
+
+    m_request_map.erase(iter);
+
+    return true;
+}
+
+
+NVMainMemory::NVMainMemoryEventManager::NVMainMemoryEventManager(EventQueue* eventq, NVMainMemory &_memory)
+    : EventManager(eventq), memory(_memory)
+{
+    memEvent = new NVMainMemoryEvent(_memory);
+}
+
+
+void NVMainMemory::NVMainMemoryEventManager::scheduleWakeup( )
+{
+    schedule(memEvent, curTick() + memory.clock);
+}
+
+
+NVMainMemory *
+NVMainMemoryParams::create()
+{
+    return new NVMainMemory(this);
+}
+
diff -r 1553e7995205 src/mem/nvmain_mem.hh
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/mem/nvmain_mem.hh	Fri Oct 12 16:01:36 2012 -0400
@@ -0,0 +1,180 @@
+/*
+ * Copyright (c) 1999-2008 Mark D. Hill and David A. Wood
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met: redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer;
+ * redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution;
+ * neither the name of the copyright holders nor the names of its
+ * contributors may be used to endorse or promote products derived from
+ * this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/*
+ *  This file is part of NVMain- A cycle accurate timing, bit-accurate
+ *  energy simulator for non-volatile memory. Originally developed by
+ *  Matt Poremba at the Pennsylvania State University.
+ *
+ *  Website: http://www.cse.psu.edu/~poremba/nvmain/
+ *  Email: mrp5060@psu.edu
+ *
+ *  ---------------------------------------------------------------------
+ *
+ *  If you use this software for publishable research, please include
+ *  the original NVMain paper in the citation list and mention the use
+ *  of NVMain.
+ *
+ */
+
+#ifndef __MEM_NVMAIN_MEM_HH__
+#define __MEM_NVMAIN_MEM_HH__
+
+
+#include "NVM/nvmain.h"
+#include "include/NVMainRequest.h"
+#include "mem/abstract_mem.hh"
+#include "mem/tport.hh"
+#include "params/NVMainMemory.hh"
+#include "sim/eventq.hh"
+#include "src/Config.h"
+#include "src/NVMObject.h"
+#include "src/SimInterface.h"
+
+class NVMainMemory : public AbstractMemory, public NVM::NVMObject
+{
+  private:
+
+    class MemoryPort : public SimpleTimingPort
+    {
+        friend class NVMainMemory;
+
+        NVMainMemory& memory;
+
+      public:
+
+        MemoryPort(const std::string& _name, NVMainMemory& _memory);
+
+      protected:
+
+        virtual Tick recvAtomic(PacketPtr pkt);
+
+        virtual void recvFunctional(PacketPtr pkt);
+
+        virtual bool recvTimingReq(PacketPtr pkt);
+
+        virtual AddrRangeList getAddrRanges() const;
+
+    };
+
+    class NVMainMemoryEvent : public Event
+    {
+        friend class NVMainMemory;
+
+        NVMainMemory& memory;
+
+      public:
+
+        NVMainMemoryEvent(NVMainMemory &_memory) : memory(_memory) { }
+        ~NVMainMemoryEvent() { }
+
+        void process();
+    };
+
+    class NVMainMemoryEventManager : public EventManager
+    {
+        friend class NVMainMemory;
+
+        NVMainMemory& memory;
+
+        NVMainMemoryEvent *memEvent;
+
+      public:
+
+        NVMainMemoryEventManager(EventQueue *eventq, NVMainMemory &_memory);
+        ~NVMainMemoryEventManager( ) { }
+
+        void scheduleWakeup( );
+    };
+
+    struct NVMainMemoryRequest
+    {
+        PacketPtr packet;
+        NVM::NVMainRequest *request;
+        Tick issueTick;
+        bool atomic;
+    };
+
+    MemoryPort port;
+    NVMainMemoryEventManager *eventManager;
+
+    NVM::NVMain *m_nvmainPtr;
+    NVM::Config *m_nvmainConfig;
+    NVM::SimInterface *m_nvmainSimInterface;
+    std::string m_nvmainConfigPath;
+
+    bool m_nacked_requests;
+    bool m_slot_available;
+    float m_avgAtomicLatency;
+    uint64_t m_numAtomicAccesses;
+
+    Tick clock;
+    Tick lat;
+    Tick lat_var;
+    bool nvmain_atomic;
+
+    uint64_t BusWidth;
+    uint64_t tBURST;
+    uint64_t RATE;
+
+    Tick lastWakeup;
+
+    std::list<NVMainMemoryRequest *> m_request_list;
+
+    std::map<NVM::NVMainRequest *, NVMainMemoryRequest *> m_request_map;
+
+  public:
+
+    typedef NVMainMemoryParams Params;
+    NVMainMemory(const Params *p);
+    virtual ~NVMainMemory() { }
+
+    SlavePort& getSlavePort(const std::string& if_name, int idx = -1);
+    void init();
+
+    const Params *
+    params() const
+    {
+        return dynamic_cast<const Params *>(_params);
+    }
+
+
+    bool RequestComplete( NVM::NVMainRequest *req );
+
+    void Cycle() { }
+
+  protected:
+
+    Tick doAtomicAccess(PacketPtr pkt);
+    void doFunctionalAccess(PacketPtr pkt);
+    void Sync();
+
+};
+
+#endif
+
diff -r 1553e7995205 src/mem/protocol/MESI_CMP_directory-L1cache.sm
--- a/src/mem/protocol/MESI_CMP_directory-L1cache.sm	Fri Oct 05 14:14:36 2012 -0400
+++ b/src/mem/protocol/MESI_CMP_directory-L1cache.sm	Fri Oct 12 16:01:36 2012 -0400
@@ -377,6 +377,8 @@
         out_msg.MessageSize := MessageSizeType:Control;
         out_msg.Prefetch := in_msg.Prefetch;
         out_msg.AccessMode := in_msg.AccessMode;
+        out_msg.ProgramCounter := in_msg.ProgramCounter;
+        out_msg.ThreadId := in_msg.contextId;
       }
     }
   }
@@ -394,6 +396,8 @@
         out_msg.MessageSize := MessageSizeType:Control;
         out_msg.Prefetch := in_msg.Prefetch;
         out_msg.AccessMode := in_msg.AccessMode;
+        out_msg.ProgramCounter := in_msg.ProgramCounter;
+        out_msg.ThreadId := in_msg.contextId;
       }
     }
   }
@@ -413,6 +417,8 @@
         out_msg.MessageSize := MessageSizeType:Control;
         out_msg.Prefetch := in_msg.Prefetch;
         out_msg.AccessMode := in_msg.AccessMode;
+        out_msg.ProgramCounter := in_msg.ProgramCounter;
+        out_msg.ThreadId := in_msg.contextId;
       }
     }
   }
@@ -430,6 +436,8 @@
         out_msg.MessageSize := MessageSizeType:Control;
         out_msg.Prefetch := in_msg.Prefetch;
         out_msg.AccessMode := in_msg.AccessMode;
+        out_msg.ProgramCounter := in_msg.ProgramCounter;
+        out_msg.ThreadId := in_msg.contextId;
       }
     }
   }
diff -r 1553e7995205 src/mem/protocol/MESI_CMP_directory-L2cache.sm
--- a/src/mem/protocol/MESI_CMP_directory-L2cache.sm	Fri Oct 05 14:14:36 2012 -0400
+++ b/src/mem/protocol/MESI_CMP_directory-L2cache.sm	Fri Oct 12 16:01:36 2012 -0400
@@ -400,6 +400,8 @@
         out_msg.Requestor := machineID;
         out_msg.Destination.add(map_Address_to_Directory(address));
         out_msg.MessageSize := MessageSizeType:Control;
+        out_msg.ProgramCounter := in_msg.ProgramCounter;
+        out_msg.ThreadId := in_msg.ThreadId;
       }
     }
   }
@@ -413,6 +415,8 @@
         out_msg.Requestor := in_msg.Requestor;
         out_msg.Destination.add(cache_entry.Exclusive);
         out_msg.MessageSize := MessageSizeType:Request_Control;
+        out_msg.ProgramCounter := in_msg.ProgramCounter;
+        out_msg.ThreadId := in_msg.ThreadId;
       }
     }
   }
diff -r 1553e7995205 src/mem/protocol/MESI_CMP_directory-dir.sm
--- a/src/mem/protocol/MESI_CMP_directory-dir.sm	Fri Oct 05 14:14:36 2012 -0400
+++ b/src/mem/protocol/MESI_CMP_directory-dir.sm	Fri Oct 12 16:01:36 2012 -0400
@@ -37,7 +37,7 @@
 
 machine(Directory, "MESI_CMP_filter_directory protocol") 
  : DirectoryMemory * directory,
-   MemoryControl * memBuffer,
+   NVMainControl * memBuffer,
    int to_mem_ctrl_latency = 1,
    int directory_latency = 6
 {
@@ -311,6 +311,8 @@
         out_msg.MessageSize := in_msg.MessageSize;
         out_msg.Prefetch := in_msg.Prefetch;
         out_msg.DataBlk := getDirectoryEntry(in_msg.Address).DataBlk;
+        out_msg.ProgramCounter := in_msg.ProgramCounter;
+        out_msg.ThreadId := in_msg.ThreadId;
 
         DPRINTF(RubySlicc, "%s\n", out_msg);
       }
@@ -350,6 +352,8 @@
         out_msg.OriginalRequestorMachId := machineID;
         out_msg.MessageSize := in_msg.MessageSize;
         out_msg.DataBlk := getDirectoryEntry(address).DataBlk;
+        out_msg.ProgramCounter := in_msg.ProgramCounter;
+        out_msg.ThreadId := in_msg.ThreadId;
         DPRINTF(RubySlicc, "%s\n", out_msg);
       }
     }
diff -r 1553e7995205 src/mem/protocol/MESI_CMP_directory-msg.sm
--- a/src/mem/protocol/MESI_CMP_directory-msg.sm	Fri Oct 05 14:14:36 2012 -0400
+++ b/src/mem/protocol/MESI_CMP_directory-msg.sm	Fri Oct 12 16:01:36 2012 -0400
@@ -70,6 +70,8 @@
   int Len;
   bool Dirty, default="false",  desc="Dirty bit";
   PrefetchBit Prefetch,         desc="Is this a prefetch request";
+  Address ProgramCounter,       desc="PC that caused this request";
+  int ThreadId,                 desc="Context ID of issuing request";
 }
 
 // ResponseMsg
diff -r 1553e7995205 src/mem/protocol/RubySlicc_MemControl.sm
--- a/src/mem/protocol/RubySlicc_MemControl.sm	Fri Oct 05 14:14:36 2012 -0400
+++ b/src/mem/protocol/RubySlicc_MemControl.sm	Fri Oct 12 16:01:36 2012 -0400
@@ -61,4 +61,6 @@
   PrefetchBit Prefetch,         desc="Is this a prefetch request";
   bool ReadX,                   desc="Exclusive";
   int Acks,                     desc="How many acks to expect";
+  Address ProgramCounter,       desc="Program Counter causing miss";
+  int ThreadId,                 desc="Context ID of issuing request";
 }
diff -r 1553e7995205 src/mem/protocol/RubySlicc_Types.sm
--- a/src/mem/protocol/RubySlicc_Types.sm	Fri Oct 05 14:14:36 2012 -0400
+++ b/src/mem/protocol/RubySlicc_Types.sm	Fri Oct 12 16:01:36 2012 -0400
@@ -166,6 +166,10 @@
   void recordRequestType(CacheRequestType);
 }
 
+structure (NVMainControl, inport="yes", outport="yes", external = "yes") {
+
+}
+
 structure (DMASequencer, external = "yes") {
   void ackCallback();
   void dataCallback(DataBlock);
diff -r 1553e7995205 src/mem/request.hh
--- a/src/mem/request.hh	Fri Oct 05 14:14:36 2012 -0400
+++ b/src/mem/request.hh	Fri Oct 12 16:01:36 2012 -0400
@@ -147,6 +147,7 @@
      */
     Addr _paddr;
 
+  private:
     /**
      * The size of the request. This field must be set when vaddr or
      * paddr is written via setVirt() or setPhys(), so it is always
@@ -183,8 +184,10 @@
      * store conditional or the compare value for a CAS. */
     uint64_t _extraData;
 
+  private:
     /** The context ID (for statistics, typically). */
     int _contextId;
+
     /** The thread ID (id within this CPU) */
     int _threadId;
 
diff -r 1553e7995205 src/mem/ruby/SConscript
--- a/src/mem/ruby/SConscript	Fri Oct 05 14:14:36 2012 -0400
+++ b/src/mem/ruby/SConscript	Fri Oct 12 16:01:36 2012 -0400
@@ -114,3 +114,4 @@
 MakeInclude('system/Sequencer.hh')
 MakeInclude('system/TBETable.hh')
 MakeInclude('system/TimerTable.hh')
+MakeInclude('system/NVMainControl.hh')
diff -r 1553e7995205 src/mem/ruby/common/Address.hh
--- a/src/mem/ruby/common/Address.hh	Fri Oct 05 14:14:36 2012 -0400
+++ b/src/mem/ruby/common/Address.hh	Fri Oct 12 16:01:36 2012 -0400
@@ -88,7 +88,7 @@
         m_address |= (physical_address_t) offset;
     }
 
-  private:
+  //private:
     physical_address_t m_address;
 };
 
diff -r 1553e7995205 src/mem/ruby/network/Network.hh
--- a/src/mem/ruby/network/Network.hh	Fri Oct 05 14:14:36 2012 -0400
+++ b/src/mem/ruby/network/Network.hh	Fri Oct 12 16:01:36 2012 -0400
@@ -94,6 +94,8 @@
     virtual void clearStats() = 0;
     virtual void print(std::ostream& out) const = 0;
 
+    Topology* getTopologyPtr() const { return m_topology_ptr; }
+
   protected:
     // Private copy constructor and assignment operator
     Network(const Network& obj);
diff -r 1553e7995205 src/mem/ruby/network/Topology.hh
--- a/src/mem/ruby/network/Topology.hh	Fri Oct 05 14:14:36 2012 -0400
+++ b/src/mem/ruby/network/Topology.hh	Fri Oct 12 16:01:36 2012 -0400
@@ -82,6 +82,8 @@
     void clearStats();
     void print(std::ostream& out) const { out << "[Topology]"; }
 
+    std::vector<AbstractController*> getControllerVector() const { return m_controller_vector; }
+
   protected:
     void addLink(SwitchID src, SwitchID dest, BasicLink* link,
                  LinkDirection dir);
diff -r 1553e7995205 src/mem/ruby/profiler/CacheProfiler.cc
--- a/src/mem/ruby/profiler/CacheProfiler.cc	Fri Oct 05 14:14:36 2012 -0400
+++ b/src/mem/ruby/profiler/CacheProfiler.cc	Fri Oct 12 16:01:36 2012 -0400
@@ -37,6 +37,8 @@
 {
     m_description = description;
 
+    std::cout << "Created cache profiler : " << m_description << std::endl;
+
     clearStats();
 }
 
diff -r 1553e7995205 src/mem/ruby/profiler/CacheProfiler.hh
--- a/src/mem/ruby/profiler/CacheProfiler.hh	Fri Oct 05 14:14:36 2012 -0400
+++ b/src/mem/ruby/profiler/CacheProfiler.hh	Fri Oct 12 16:01:36 2012 -0400
@@ -59,6 +59,8 @@
 
     void print(std::ostream& out) const;
 
+    int64 getMisses() const { return m_misses; }
+
   private:
     // Private copy constructor and assignment operator
     CacheProfiler(const CacheProfiler& obj);
diff -r 1553e7995205 src/mem/ruby/slicc_interface/AbstractController.hh
--- a/src/mem/ruby/slicc_interface/AbstractController.hh	Fri Oct 05 14:14:36 2012 -0400
+++ b/src/mem/ruby/slicc_interface/AbstractController.hh	Fri Oct 12 16:01:36 2012 -0400
@@ -38,6 +38,7 @@
 #include "mem/ruby/common/DataBlock.hh"
 #include "mem/ruby/network/Network.hh"
 #include "mem/ruby/recorder/CacheRecorder.hh"
+#include "mem/ruby/profiler/CacheProfiler.hh"
 #include "params/RubyController.hh"
 #include "sim/sim_object.hh"
 
@@ -68,6 +69,7 @@
     virtual void clearStats() = 0;
     virtual void recordCacheTrace(int cntrl, CacheRecorder* tr) = 0;
     virtual Sequencer* getSequencer() const = 0;
+    virtual CacheProfiler* getCacheProfiler() const = 0;
 };
 
 #endif // __MEM_RUBY_SLICC_INTERFACE_ABSTRACTCONTROLLER_HH__
diff -r 1553e7995205 src/mem/ruby/system/CacheMemory.hh
--- a/src/mem/ruby/system/CacheMemory.hh	Fri Oct 05 14:14:36 2012 -0400
+++ b/src/mem/ruby/system/CacheMemory.hh	Fri Oct 12 16:01:36 2012 -0400
@@ -128,6 +128,8 @@
 
     Stats::Scalar numTagArrayStalls;
     Stats::Scalar numDataArrayStalls;
+
+    CacheProfiler *getCacheProfiler() const { return m_profiler_ptr; }
   private:
     // convert a Address to its location in the cache
     Index addressToCacheSet(const Address& address) const;
diff -r 1553e7995205 src/mem/ruby/system/MemoryNode.hh
--- a/src/mem/ruby/system/MemoryNode.hh	Fri Oct 05 14:14:36 2012 -0400
+++ b/src/mem/ruby/system/MemoryNode.hh	Fri Oct 12 16:01:36 2012 -0400
@@ -57,6 +57,7 @@
         m_addr = addr;
         m_is_mem_read = is_mem_read;
         m_is_dirty_wb = !is_mem_read;
+        m_metadata = NULL;
     }
 
     // new constructor
@@ -70,6 +71,22 @@
         m_addr = addr;
         m_is_mem_read = is_mem_read;
         m_is_dirty_wb = is_dirty_wb;
+        m_metadata = NULL;
+    }
+
+
+    // new constructor with metadata
+    MemoryNode(const Time& time, const MsgPtr& msgptr,
+               const physical_address_t addr, void * metadata,
+               const bool is_mem_read, const bool is_dirty_wb)
+    {
+        m_time = time;
+        m_msg_counter = 0;
+        m_msgptr = msgptr;
+        m_addr = addr;
+        m_metadata = metadata;
+        m_is_mem_read = is_mem_read;
+        m_is_dirty_wb = is_dirty_wb;
     }
 
     void print(std::ostream& out) const;
@@ -80,6 +97,7 @@
     physical_address_t m_addr;
     bool m_is_mem_read;
     bool m_is_dirty_wb;
+    void * m_metadata;
 };
 
 inline std::ostream&
diff -r 1553e7995205 src/mem/ruby/system/NVMainControl.cc
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/mem/ruby/system/NVMainControl.cc	Fri Oct 12 16:01:36 2012 -0400
@@ -0,0 +1,375 @@
+/*
+ * Copyright (c) 1999-2008 Mark D. Hill and David A. Wood
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met: redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer;
+ * redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution;
+ * neither the name of the copyright holders nor the names of its
+ * contributors may be used to endorse or promote products derived from
+ * this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+
+#include "SimInterface/NullInterface/NullInterface.h"
+#include "base/cprintf.hh"
+#include "include/NVMainRequest.h"
+#include "mem/ruby/common/Address.hh"
+#include "mem/ruby/common/Consumer.hh"
+#include "mem/ruby/common/Global.hh"
+#include "mem/ruby/network/Network.hh"
+#include "mem/ruby/profiler/Profiler.hh"
+#include "mem/ruby/slicc_interface/NetworkMessage.hh"
+#include "mem/ruby/slicc_interface/RubySlicc_ComponentMapping.hh"
+#include "mem/ruby/system/NVMainControl.hh"
+#include "mem/ruby/system/System.hh"
+#include "mem/packet.hh"
+#include "mem/request.hh"
+#include "mem/simple_mem.hh"
+
+using namespace NVM;
+
+class Consumer;
+
+
+std::ostream&
+operator<<(std::ostream& out, const NVMainControl& obj)
+{
+    obj.print(out);
+    out << std::flush;
+    return out;
+}
+
+
+
+NVMainControl::NVMainControl(const Params *p)
+    : ClockedObject((const ClockedObjectParams *)p), Consumer(this)
+{
+    char *cfgparams;
+    char *cfgvalues;
+    char *cparam, *cvalue;
+
+    char *saveptr1, *saveptr2;
+
+    m_nvmainPtr = NULL;
+    m_slot_available = true;
+    m_nacked_requests = false;
+
+    m_nvmainConfigPath = p->config;
+    m_physMem = p->physicalMem;
+
+    m_nvmainConfig = new Config( );
+
+    m_nvmainConfig->Read( m_nvmainConfigPath );
+    std::cout << "NVMainControl: Reading NVMain config file: " << m_nvmainConfigPath << "." << std::endl;
+
+
+    for( cfgparams = (char *)p->configparams.c_str(), cfgvalues = (char *)p->configvalues.c_str()
+         ; ; cfgparams = NULL, cfgvalues = NULL )
+    {
+        cparam = strtok_r( cfgparams, ",", &saveptr1 );
+        cvalue = strtok_r( cfgvalues, ",", &saveptr2 );
+
+        if( cparam == NULL || cvalue == NULL )
+            break;
+
+        std::cout << "NVMain: Overriding parameter `" << cparam << "' with `" << cvalue << "'" << std::endl;
+
+        m_nvmainConfig->SetValue( cparam, cvalue );
+    }
+}
+
+void
+NVMainControl::init()
+{
+    m_nvmainPtr = new NVMain( );
+    m_nvmainSimInterface = new NullInterface( );
+
+    m_nvmainConfig->SetSimInterface( m_nvmainSimInterface );
+
+    m_nvmainPtr->SetConfig( m_nvmainConfig );
+
+    // Schedule a wakeup.
+    m_consumer_ptr->scheduleEvent( 1 );
+}
+
+NVMainControl::~NVMainControl()
+{
+    std::cout << "NVMainControl dtor called!" << std::endl;
+}
+
+void
+NVMainControl::enqueue(const MsgPtr& message, int latency)
+{
+    Time current_time = g_system_ptr->getTime();
+    Time arrival_time = current_time + latency;
+
+    const MemoryMsg* memMess = safe_cast<const MemoryMsg*>(message.get());
+    physical_address_t addr = memMess->getAddress().getAddress();
+    MemoryRequestType type = memMess->getType();
+    bool is_mem_read = (type == MemoryRequestType_MEMORY_READ);
+
+    //if(!is_mem_read)
+    //    std::cout << "New memory request (" << m_msg_counter << "): addr 0x" << std::hex
+    //              << addr << ", data is " << memMess->getDataBlk( ) << (is_mem_read ? 'R' : 'W')
+    //              << std::endl;
+
+    NVMainRequest *request = new NVMainRequest( );
+
+    request->programCounter = memMess->m_ProgramCounter.m_address;
+    request->threadId = memMess->m_ThreadId;
+
+    MemoryNode thisReq(arrival_time, message, addr, (void *)request, is_mem_read, !is_mem_read);
+    enqueueMemRef(thisReq);
+}
+
+void
+NVMainControl::enqueueMemRef(MemoryNode& memRef)
+{
+    m_msg_counter++;
+    memRef.m_msg_counter = m_msg_counter;
+    int transfer_size;
+
+    transfer_size = m_nvmainConfig->GetValue( "BusWidth" ) / 8;
+    transfer_size *= m_nvmainConfig->GetValue( "tBURST" ) * m_nvmainConfig->GetValue( "RATE" );
+
+    DPRINTF(RubyMemory, "New memory request%7d: %#08x %c arrived at %lld\n",
+            m_msg_counter, (unsigned int)memRef.m_addr, memRef.m_is_mem_read ? 'R':'W',
+            memRef.m_time * g_system_ptr->clockPeriod());
+
+
+    // Build NVMainRequest and send to NVMain code.
+    NVMainRequest *request = (NVMainRequest *)memRef.m_metadata;
+    bool enqueued;
+    uint8_t *hostAddr;
+
+    Request *gem5Req = new Request( memRef.m_addr, transfer_size, 0, Request::funcMasterId );
+    Packet *gem5Pkt = new Packet( gem5Req, MemCmd::ReadReq );
+    gem5Pkt->allocate();
+    m_physMem->doFunctionalAccess( gem5Pkt );
+
+    hostAddr = new uint8_t[ transfer_size ];
+    memcpy( hostAddr, gem5Pkt->getPtr<uint8_t>(), gem5Pkt->getSize() );
+
+    //std::cout << "Memory req: " << std::hex << (unsigned int)memRef.m_addr << " "
+    //          << (memRef.m_is_mem_read ? 'R' : 'W') << " has data ";
+    //for(int i = 0; i < transfer_size; i++)
+    //  {
+    //    uint8_t byt = *(hostAddr + (transfer_size - 1) - i);
+    //
+    //    if( byt > 0xF )
+    //      std::cout << (int)byt;
+    //    else
+    //      std::cout << "0" << (int)byt;
+    //  }
+    //std::cout << std::dec << std::endl;
+
+    delete gem5Pkt;
+
+    request->access = UNKNOWN_ACCESS;
+    for(int i = 0; i < transfer_size; i++)
+    {
+        // memRef's m_msgptr's DataBlk is only correct for write data (since data is not read yet)
+        // However, nvmain needs data being read otherwise data is assumed 0 on first write, which
+        // may not be correct.
+        request->data.SetByte(i, *(hostAddr + (transfer_size - 1) - i));
+    }
+    request->address.SetPhysicalAddress(memRef.m_addr);
+    request->status = MEM_REQUEST_INCOMPLETE;
+    request->type = (memRef.m_is_mem_read) ? READ : WRITE;
+
+    //if(!memRef.m_is_mem_read)
+    //    std::cout << ((memRef.m_is_mem_read) ? "Read" : "Write") << " request for 0x"  << std::hex
+    //              << request->address.GetPhysicalAddress() << " has data " << request->data << std::endl;
+
+    //std::cout << "MemReq for 0x" << std::hex << request->address.GetPhysicalAddress( ) << " from PC "
+    //          << request->programCounter << " in core " << request->threadId << std::endl;
+
+    enqueued = m_nvmainPtr->NewRequest(request);
+    if(enqueued)
+    {
+            m_input_queue.push_back(memRef);
+        m_request_list.push_back(request);
+            m_slot_available = true;
+    }
+    else
+    {
+            m_slot_available = false;
+    }
+
+    // Schedule a wakeup.
+    m_consumer_ptr->scheduleEvent( 1 );
+}
+
+void
+NVMainControl::dequeue()
+{
+    assert(isReady());
+    m_response_queue.pop_front();
+}
+
+const Message*
+NVMainControl::peek()
+{
+    MemoryNode node = peekNode();
+    Message* msg_ptr = node.m_msgptr.get();
+    assert(msg_ptr != NULL);
+    return msg_ptr;
+}
+
+MemoryNode
+NVMainControl::peekNode()
+{
+    assert(isReady());
+    MemoryNode req = m_response_queue.front();
+    DPRINTF(RubyMemory, "Peek: memory request%7d: %#08x %c\n",
+            req.m_msg_counter, req.m_addr, req.m_is_mem_read ? 'R':'W');
+
+    return req;
+}
+
+bool
+NVMainControl::isReady()
+{
+    bool rv;
+
+    rv = ((!m_response_queue.empty()) &&
+            (m_response_queue.front().m_time <= g_system_ptr->getTime()));
+
+    return rv;
+}
+
+void
+NVMainControl::setConsumer(Consumer* consumer_ptr)
+{
+    m_consumer_ptr = consumer_ptr;
+}
+
+void
+NVMainControl::print(std::ostream& out) const
+{
+}
+
+void
+NVMainControl::printConfig(std::ostream& out)
+{
+    out << "hai2u" << std::endl;
+}
+
+void
+NVMainControl::clearStats() const
+{
+    std::cout << "clearing stats in NVMainControl!!" << std::endl;
+}
+
+void
+NVMainControl::printStats(std::ostream& out) const
+{
+    std::cout << "printing stats from NVMainControl!!" << std::endl;
+}
+
+// Queue up a completed request to send back to directory
+void
+NVMainControl::enqueueToDirectory(MemoryNode req, int latency)
+{
+    Time arrival_time = g_system_ptr->getTime() + latency;
+    req.m_time = arrival_time;
+    m_response_queue.push_back(req);
+
+    DPRINTF(RubyMemory, "Enqueueing msg %#08x %c back to directory at %lld\n",
+            req.m_addr, req.m_is_mem_read ? 'R':'W',
+            arrival_time * g_system_ptr->clockPeriod());
+
+    // schedule the wake up
+    m_consumer_ptr->scheduleEventAbsolute(arrival_time);
+}
+
+
+bool
+NVMainControl::areNSlotsAvailable(int n)
+{
+    //std::cout << "NSlotsAvail called! Requests " << n << std::endl;
+    return m_nvmainPtr->CanIssue( NULL );
+    //return true;
+}
+
+
+bool
+NVMainControl::queueReady(int bank)
+{
+    return true;
+}
+
+
+void
+NVMainControl::issueRequest(int bank)
+{
+}
+
+void
+NVMainControl::executeCycle()
+{
+    std::list<NVMainRequest *>::iterator it;
+
+    // Check for completed requests
+    for(it = m_request_list.begin(); it != m_request_list.end(); it++)
+    {
+        NVMainRequest *creq = *it;
+
+        if(creq->status == MEM_REQUEST_COMPLETE)
+        {
+            // Find memRef in m_input_queue, remove it, and send to directory
+            std::list<MemoryNode>::iterator mit;
+
+            for(mit = m_input_queue.begin(); mit != m_input_queue.end(); mit++)
+            {
+                MemoryNode memRef = (*mit);
+
+                if(memRef.m_addr == creq->address.GetPhysicalAddress())
+                {
+                    m_input_queue.erase( mit );
+                    enqueueToDirectory( memRef, 1 );
+                    break;
+                }
+            }
+
+            it = m_request_list.erase(it);
+        }
+    }
+
+
+    // Cycle memory controller
+    m_nvmainPtr->Cycle( );
+}
+
+void
+NVMainControl::wakeup()
+{
+    // execute ALL THE THINGS!
+    executeCycle();
+
+    m_consumer_ptr->scheduleEvent( 1 );
+}
+
+NVMainControl *
+NVMMemoryControlParams::create()
+{
+    return new NVMainControl(this);
+}
+
diff -r 1553e7995205 src/mem/ruby/system/NVMainControl.hh
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/mem/ruby/system/NVMainControl.hh	Fri Oct 12 16:01:36 2012 -0400
@@ -0,0 +1,134 @@
+/*
+ * Copyright (c) 1999-2008 Mark D. Hill and David A. Wood
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met: redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer;
+ * redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution;
+ * neither the name of the copyright holders nor the names of its
+ * contributors may be used to endorse or promote products derived from
+ * this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/*
+ *  This file is part of NVMain- A cycle accurate timing, bit-accurate
+ *  energy simulator for non-volatile memory. Originally developed by
+ *  Matt Poremba at the Pennsylvania State University.
+ *
+ *  Website: http://www.cse.psu.edu/~poremba/nvmain/
+ *  Email: mrp5060@psu.edu
+ *
+ *  ---------------------------------------------------------------------
+ *
+ *  If you use this software for publishable research, please include
+ *  the original NVMain paper in the citation list and mention the use
+ *  of NVMain.
+ *
+ */
+
+#ifndef __MEM_RUBY_SYSTEM_NVMAIN_CONTROL_HH__
+#define __MEM_RUBY_SYSTEM_NVMAIN_CONTROL_HH__
+
+#include <iostream>
+#include <list>
+#include <string>
+
+#include "NVM/nvmain.h"
+#include "mem/protocol/MemoryMsg.hh"
+#include "mem/ruby/common/Address.hh"
+#include "mem/ruby/common/Consumer.hh"
+#include "mem/ruby/common/Global.hh"
+#include "mem/ruby/profiler/MemCntrlProfiler.hh"
+#include "mem/ruby/slicc_interface/Message.hh"
+#include "mem/ruby/system/AbstractMemOrCache.hh"
+#include "mem/ruby/system/MemoryNode.hh"
+#include "mem/ruby/system/System.hh"
+#include "mem/physical.hh"
+#include "params/NVMMemoryControl.hh"
+#include "sim/clocked_object.hh"
+#include "src/Config.h"
+#include "src/SimInterface.h"
+
+class Consumer;
+
+class NVMainControl :
+    public ClockedObject, public Consumer, public AbstractMemOrCache
+{
+  public:
+    typedef NVMMemoryControlParams Params;
+    const Params *params() const
+    { return dynamic_cast<const Params *>(_params); }
+
+    NVMainControl(const Params *p);
+    void init();
+
+    ~NVMainControl();
+
+    void wakeup();
+
+    void setConsumer(Consumer* consumer_ptr);
+    Consumer* getConsumer() { return m_consumer_ptr; };
+    void setDescription(const std::string& name) { m_description = name; };
+    std::string getDescription() { return m_description; };
+
+    void enqueue(const MsgPtr& message, int latency );
+    void enqueueMemRef(MemoryNode& memRef);
+    void dequeue();
+    const Message* peek();
+    MemoryNode peekNode();
+    bool isReady();
+    bool areNSlotsAvailable(int n);
+
+
+    void printConfig(std::ostream& out);
+    void print(std::ostream& out) const;
+    void clearStats() const;
+    void printStats(std::ostream& out) const;
+
+
+  private:
+    void enqueueToDirectory(MemoryNode req, int latency);
+    bool queueReady(int bank);
+    void issueRequest(int bank);
+    void executeCycle();
+
+    NVMainControl (const NVMainControl& obj);
+    NVMainControl& operator=(const NVMainControl& obj);
+
+    Consumer* m_consumer_ptr;
+    std::string m_description;
+    int m_msg_counter;
+    int m_awakened;
+
+    bool m_slot_available;
+    bool m_nacked_requests;
+    NVM::NVMain *m_nvmainPtr;
+    SimpleMemory *m_physMem;
+    NVM::SimInterface *m_nvmainSimInterface;
+    NVM::Config *m_nvmainConfig;
+    std::string m_nvmainConfigPath;
+
+    std::list<MemoryNode> m_response_queue;
+    std::list<MemoryNode> m_input_queue;
+    std::list<MemoryNode>* m_bankQueues;
+
+    std::list<NVM::NVMainRequest *> m_request_list;
+};
+
+#endif // __MEM_RUBY_SYSTEM_MEMORY_CONTROL_HH__
diff -r 1553e7995205 src/mem/ruby/system/NVMainControl.py
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/mem/ruby/system/NVMainControl.py	Fri Oct 12 16:01:36 2012 -0400
@@ -0,0 +1,40 @@
+# Copyright (c) 2009 Advanced Micro Devices, Inc.
+# All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions are
+# met: redistributions of source code must retain the above copyright
+# notice, this list of conditions and the following disclaimer;
+# redistributions in binary form must reproduce the above copyright
+# notice, this list of conditions and the following disclaimer in the
+# documentation and/or other materials provided with the distribution;
+# neither the name of the copyright holders nor the names of its
+# contributors may be used to endorse or promote products derived from
+# this software without specific prior written permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+#
+
+from m5.params import *
+from m5.SimObject import SimObject
+
+class NVMMemoryControl(SimObject):
+    type = 'NVMMemoryControl'
+    cxx_class = 'NVMainControl'
+    version = Param.Int("")
+    config = Param.String("NULL", "")
+    physicalMem = Param.SimpleMemory("")
+
+    configparams = Param.String("", "")
+    configvalues = Param.String("", "")
+
diff -r 1553e7995205 src/mem/ruby/system/SConscript
--- a/src/mem/ruby/system/SConscript	Fri Oct 05 14:14:36 2012 -0400
+++ b/src/mem/ruby/system/SConscript	Fri Oct 12 16:01:36 2012 -0400
@@ -37,6 +37,7 @@
 SimObject('Sequencer.py')
 SimObject('DirectoryMemory.py')
 SimObject('MemoryControl.py')
+SimObject('NVMainControl.py')
 SimObject('WireBuffer.py')
 SimObject('RubySystem.py')
 SimObject('RubyMemoryControl.py')
@@ -46,6 +47,7 @@
 Source('SparseMemory.cc')
 Source('CacheMemory.cc')
 Source('MemoryControl.cc')
+Source('NVMainControl.cc')
 Source('WireBuffer.cc')
 Source('RubyMemoryControl.cc')
 Source('MemoryNode.cc')
diff -r 1553e7995205 src/mem/simple_mem.hh
--- a/src/mem/simple_mem.hh	Fri Oct 05 14:14:36 2012 -0400
+++ b/src/mem/simple_mem.hh	Fri Oct 12 16:01:36 2012 -0400
@@ -128,7 +128,7 @@
     virtual SlavePort& getSlavePort(const std::string& if_name, int idx = -1);
     virtual void init();
 
-  protected:
+  //protected:
 
     Tick doAtomicAccess(PacketPtr pkt);
     void doFunctionalAccess(PacketPtr pkt);
diff -r 1553e7995205 src/mem/slicc/symbols/StateMachine.py
--- a/src/mem/slicc/symbols/StateMachine.py	Fri Oct 05 14:14:36 2012 -0400
+++ b/src/mem/slicc/symbols/StateMachine.py	Fri Oct 12 16:01:36 2012 -0400
@@ -40,6 +40,7 @@
                     "Sequencer": "RubySequencer",
                     "DirectoryMemory": "RubyDirectoryMemory",
                     "MemoryControl": "MemoryControl",
+                    "NVMainControl": "NVMMemoryControl",
                     "DMASequencer": "DMASequencer"
                     }
 
@@ -268,6 +269,7 @@
     void unblock(Address addr);
     void recordCacheTrace(int cntrl, CacheRecorder* tr);
     Sequencer* getSequencer() const;
+    CacheProfiler* getCacheProfiler() const;
 
 private:
 ''')
@@ -717,6 +719,26 @@
     return $seq_ident;
 }
 
+
+CacheProfiler*
+$c_ident::getCacheProfiler() const
+{
+''')
+
+        code.indent()
+        foundCacheMemory = False
+        for param in self.config_parameters:
+            if param.type_ast.type.ident == "CacheMemory":
+                code('return m_${{param.ident}}_ptr->getCacheProfiler();')
+                foundCacheMemory = True
+                break
+
+        if foundCacheMemory == False:
+            code('return NULL;')
+
+        code.dedent()
+        code('''}
+
 const int &
 $c_ident::getVersion() const
 {
diff -r 1553e7995205 src/sim/main.cc
--- a/src/sim/main.cc	Fri Oct 05 14:14:36 2012 -0400
+++ b/src/sim/main.cc	Fri Oct 12 16:01:36 2012 -0400
@@ -30,6 +30,8 @@
 
 #include <Python.h>
 
+#include <mcheck.h>
+
 #include "sim/init.hh"
 
 // main() is now pretty stripped down and just sets up python and then
@@ -41,6 +43,8 @@
 {
     int ret;
 
+    mtrace();
+
     // Initialize m5 special signal handling.
     initSignals();
 
