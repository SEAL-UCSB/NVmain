# HG changeset patch
# Parent 8f1e524e3917ed84e2e9886142873fa9fa636c3d

diff -r 8f1e524e3917 configs/ruby/MESI_CMP_directory.py
--- a/configs/ruby/MESI_CMP_directory.py	Tue Oct 16 15:24:06 2012 -0400
+++ b/configs/ruby/MESI_CMP_directory.py	Tue Oct 16 16:15:04 2012 -0400
@@ -143,8 +143,14 @@
         # Create the Ruby objects associated with the directory controller
         #
 
-        mem_cntrl = RubyMemoryControl(version = i,
-                                      ruby_system = ruby_system)
+        try:
+            mem_cntrl = NVMMemoryControl(version = i,
+                                         config = options.nvmain_config,
+                                         ruby_system = ruby_system,
+                                         physicalMem = system.physmem)
+        except:
+            mem_cntrl = RubyMemoryControl(version = i,
+                                          ruby_system = ruby_system)
 
         dir_size = MemorySize('0B')
         dir_size.value = mem_module_size
diff -r 8f1e524e3917 src/mem/protocol/MESI_CMP_directory-dir.sm
--- a/src/mem/protocol/MESI_CMP_directory-dir.sm	Tue Oct 16 15:24:06 2012 -0400
+++ b/src/mem/protocol/MESI_CMP_directory-dir.sm	Tue Oct 16 16:15:04 2012 -0400
@@ -37,7 +37,7 @@
 
 machine(Directory, "MESI_CMP_filter_directory protocol") 
  : DirectoryMemory * directory,
-   MemoryControl * memBuffer,
+   NVMainControl * memBuffer,
    int to_mem_ctrl_latency = 1,
    int directory_latency = 6
 {
diff -r 8f1e524e3917 src/mem/protocol/RubySlicc_Types.sm
--- a/src/mem/protocol/RubySlicc_Types.sm	Tue Oct 16 15:24:06 2012 -0400
+++ b/src/mem/protocol/RubySlicc_Types.sm	Tue Oct 16 16:15:04 2012 -0400
@@ -164,6 +164,10 @@
   void recordRequestType(CacheRequestType);
 }
 
+structure (NVMainControl, inport="yes", outport="yes", external = "yes") {
+
+}
+
 structure (DMASequencer, external = "yes") {
   void ackCallback();
   void dataCallback(DataBlock);
diff -r 8f1e524e3917 src/mem/ruby/SConscript
--- a/src/mem/ruby/SConscript	Tue Oct 16 15:24:06 2012 -0400
+++ b/src/mem/ruby/SConscript	Tue Oct 16 16:15:04 2012 -0400
@@ -114,3 +114,4 @@
 MakeInclude('system/Sequencer.hh')
 MakeInclude('system/TBETable.hh')
 MakeInclude('system/TimerTable.hh')
+MakeInclude('system/NVMainControl.hh')
diff -r 8f1e524e3917 src/mem/ruby/network/Network.hh
--- a/src/mem/ruby/network/Network.hh	Tue Oct 16 15:24:06 2012 -0400
+++ b/src/mem/ruby/network/Network.hh	Tue Oct 16 16:15:04 2012 -0400
@@ -105,6 +105,8 @@
     virtual uint32_t functionalWrite(Packet *pkt)
     { fatal("Functional write not implemented.\n"); }
 
+    Topology* getTopologyPtr() const { return m_topology_ptr; }
+
   protected:
     // Private copy constructor and assignment operator
     Network(const Network& obj);
diff -r 8f1e524e3917 src/mem/ruby/network/Topology.hh
--- a/src/mem/ruby/network/Topology.hh	Tue Oct 16 15:24:06 2012 -0400
+++ b/src/mem/ruby/network/Topology.hh	Tue Oct 16 16:15:04 2012 -0400
@@ -82,6 +82,8 @@
     void clearStats();
     void print(std::ostream& out) const { out << "[Topology]"; }
 
+    std::vector<AbstractController*> getControllerVector() const { return m_controller_vector; }
+
   protected:
     void addLink(SwitchID src, SwitchID dest, BasicLink* link,
                  LinkDirection dir);
diff -r 8f1e524e3917 src/mem/ruby/profiler/CacheProfiler.hh
--- a/src/mem/ruby/profiler/CacheProfiler.hh	Tue Oct 16 15:24:06 2012 -0400
+++ b/src/mem/ruby/profiler/CacheProfiler.hh	Tue Oct 16 16:15:04 2012 -0400
@@ -59,6 +59,8 @@
 
     void print(std::ostream& out) const;
 
+    int64 getMisses() const { return m_misses; }
+
   private:
     // Private copy constructor and assignment operator
     CacheProfiler(const CacheProfiler& obj);
diff -r 8f1e524e3917 src/mem/ruby/slicc_interface/AbstractController.hh
--- a/src/mem/ruby/slicc_interface/AbstractController.hh	Tue Oct 16 15:24:06 2012 -0400
+++ b/src/mem/ruby/slicc_interface/AbstractController.hh	Tue Oct 16 16:15:04 2012 -0400
@@ -32,13 +32,14 @@
 #include <iostream>
 #include <string>
 
-#include "mem/packet.hh"
 #include "mem/protocol/AccessPermission.hh"
 #include "mem/ruby/common/Address.hh"
 #include "mem/ruby/common/Consumer.hh"
 #include "mem/ruby/common/DataBlock.hh"
 #include "mem/ruby/network/Network.hh"
+#include "mem/ruby/profiler/CacheProfiler.hh"
 #include "mem/ruby/recorder/CacheRecorder.hh"
+#include "mem/packet.hh"
 #include "params/RubyController.hh"
 #include "sim/sim_object.hh"
 
@@ -69,6 +70,7 @@
     virtual void clearStats() = 0;
     virtual void recordCacheTrace(int cntrl, CacheRecorder* tr) = 0;
     virtual Sequencer* getSequencer() const = 0;
+    virtual CacheProfiler* getCacheProfiler() const = 0;
 
     //! These functions are used by ruby system to read/write the message
     //! queues that exist with in the controller.
diff -r 8f1e524e3917 src/mem/ruby/system/CacheMemory.hh
--- a/src/mem/ruby/system/CacheMemory.hh	Tue Oct 16 15:24:06 2012 -0400
+++ b/src/mem/ruby/system/CacheMemory.hh	Tue Oct 16 16:15:04 2012 -0400
@@ -128,6 +128,8 @@
 
     Stats::Scalar numTagArrayStalls;
     Stats::Scalar numDataArrayStalls;
+
+    CacheProfiler *getCacheProfiler() const { return m_profiler_ptr; }
   private:
     // convert a Address to its location in the cache
     Index addressToCacheSet(const Address& address) const;
diff -r 8f1e524e3917 src/mem/ruby/system/MemoryNode.hh
--- a/src/mem/ruby/system/MemoryNode.hh	Tue Oct 16 15:24:06 2012 -0400
+++ b/src/mem/ruby/system/MemoryNode.hh	Tue Oct 16 16:15:04 2012 -0400
@@ -57,6 +57,7 @@
         m_addr = addr;
         m_is_mem_read = is_mem_read;
         m_is_dirty_wb = !is_mem_read;
+        m_metadata = NULL;
     }
 
     // new constructor
@@ -70,6 +71,22 @@
         m_addr = addr;
         m_is_mem_read = is_mem_read;
         m_is_dirty_wb = is_dirty_wb;
+        m_metadata = NULL;
+    }
+
+
+    // new constructor with metadata
+    MemoryNode(const Time& time, const MsgPtr& msgptr,
+               const physical_address_t addr, void * metadata,
+               const bool is_mem_read, const bool is_dirty_wb)
+    {
+        m_time = time;
+        m_msg_counter = 0;
+        m_msgptr = msgptr;
+        m_addr = addr;
+        m_metadata = metadata;
+        m_is_mem_read = is_mem_read;
+        m_is_dirty_wb = is_dirty_wb;
     }
 
     void print(std::ostream& out) const;
@@ -80,6 +97,7 @@
     physical_address_t m_addr;
     bool m_is_mem_read;
     bool m_is_dirty_wb;
+    void * m_metadata;
 };
 
 inline std::ostream&
diff -r 8f1e524e3917 src/mem/ruby/system/NVMainControl.cc
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/mem/ruby/system/NVMainControl.cc	Tue Oct 16 16:15:04 2012 -0400
@@ -0,0 +1,496 @@
+/*
+ * Copyright (c) 1999-2008 Mark D. Hill and David A. Wood
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met: redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer;
+ * redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution;
+ * neither the name of the copyright holders nor the names of its
+ * contributors may be used to endorse or promote products derived from
+ * this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+
+#include "SimInterface/NullInterface/NullInterface.h"
+#include "base/cprintf.hh"
+#include "include/NVMainRequest.h"
+#include "mem/ruby/common/Address.hh"
+#include "mem/ruby/common/Consumer.hh"
+#include "mem/ruby/common/Global.hh"
+#include "mem/ruby/network/Network.hh"
+#include "mem/ruby/profiler/Profiler.hh"
+#include "mem/ruby/slicc_interface/NetworkMessage.hh"
+#include "mem/ruby/slicc_interface/RubySlicc_ComponentMapping.hh"
+#include "mem/ruby/system/NVMainControl.hh"
+#include "mem/ruby/system/System.hh"
+#include "mem/packet.hh"
+#include "mem/request.hh"
+#include "mem/simple_mem.hh"
+
+using namespace NVM;
+
+class Consumer;
+
+
+std::ostream&
+operator<<(std::ostream& out, const NVMainControl& obj)
+{
+    obj.print(out);
+    out << std::flush;
+    return out;
+}
+
+
+
+NVMainControl::NVMainControl(const Params *p)
+    : MemoryControl(p)
+{
+    char *cfgparams;
+    char *cfgvalues;
+    char *cparam, *cvalue;
+
+    char *saveptr1, *saveptr2;
+
+    m_nvmainPtr = NULL;
+    m_slot_available = true;
+    m_nacked_requests = false;
+
+    m_nvmainConfigPath = p->config;
+    m_physMem = p->physicalMem;
+
+    m_nvmainConfig = new Config( );
+
+    m_nvmainConfig->Read( m_nvmainConfigPath );
+    std::cout << "NVMainControl: Reading NVMain config file: " << m_nvmainConfigPath << "." << std::endl;
+
+
+    for( cfgparams = (char *)p->configparams.c_str(), cfgvalues = (char *)p->configvalues.c_str()
+         ; ; cfgparams = NULL, cfgvalues = NULL )
+    {
+        cparam = strtok_r( cfgparams, ",", &saveptr1 );
+        cvalue = strtok_r( cfgvalues, ",", &saveptr2 );
+
+        if( cparam == NULL || cvalue == NULL )
+            break;
+
+        std::cout << "NVMain: Overriding parameter `" << cparam << "' with `" << cvalue << "'" << std::endl;
+
+        m_nvmainConfig->SetValue( cparam, cvalue );
+    }
+}
+
+void
+NVMainControl::init()
+{
+    m_nvmainPtr = new NVMain( );
+    m_nvmainSimInterface = new NullInterface( );
+
+    m_nvmainConfig->SetSimInterface( m_nvmainSimInterface );
+
+    m_nvmainPtr->SetConfig( m_nvmainConfig );
+
+    AddChild( m_nvmainPtr );
+    m_nvmainPtr->SetParent( this );
+
+    statPrinter.nvmainPtr = m_nvmainPtr;
+    registerExitCallback( &statPrinter );
+
+    // Schedule a wakeup.
+    //if(!m_event.scheduled())
+    //{
+    //    schedule(m_event, nextCycle());
+    //}
+}
+
+NVMainControl::~NVMainControl()
+{
+    std::cout << "NVMainControl dtor called!" << std::endl;
+}
+
+// Not used.
+const int
+NVMainControl::getRow(const physical_address_t) const
+{
+    return -1;
+}
+
+// Not used.
+const int
+NVMainControl::getRank(const physical_address_t) const
+{
+    return -1;
+}
+
+// Not used.
+const int
+NVMainControl::getBank(const physical_address_t) const
+{
+    return -1;
+}
+
+// Not used.
+const int
+NVMainControl::getChannel(const physical_address_t) const
+{
+    return -1;
+}
+
+int
+NVMainControl::getBanksPerRank()
+{
+    return -1;
+}
+
+int
+NVMainControl::getRanksPerDimm()
+{
+    return -1;
+}
+
+int
+NVMainControl::getDimmsPerChannel()
+{
+    return -1;
+}
+
+void
+NVMainControl::reset()
+{
+}
+
+unsigned int
+NVMainControl::drain(Event *)
+{
+    return 0;
+}
+
+void
+NVMainControl::enqueue(const MsgPtr& message, int latency)
+{
+    Time current_time = g_system_ptr->getTime();
+    Time arrival_time = current_time + latency;
+
+    const MemoryMsg* memMess = safe_cast<const MemoryMsg*>(message.get());
+    physical_address_t addr = memMess->getAddress().getAddress();
+    MemoryRequestType type = memMess->getType();
+    bool is_mem_read = (type == MemoryRequestType_MEMORY_READ);
+
+    //if(!is_mem_read)
+    //    std::cout << "New memory request (" << m_msg_counter << "): addr 0x" << std::hex
+    //              << addr << ", data is " << memMess->getDataBlk( ) << (is_mem_read ? 'R' : 'W')
+    //              << std::endl;
+
+    NVMainRequest *request = new NVMainRequest( );
+
+    MemoryNode thisReq(arrival_time, message, addr, (void *)request, is_mem_read, !is_mem_read);
+    enqueueMemRef(thisReq);
+}
+
+void
+NVMainControl::enqueueMemRef(MemoryNode& memRef)
+{
+    m_msg_counter++;
+    memRef.m_msg_counter = m_msg_counter;
+    int transfer_size;
+
+    transfer_size = m_nvmainConfig->GetValue( "BusWidth" ) / 8;
+    transfer_size *= m_nvmainConfig->GetValue( "tBURST" ) * m_nvmainConfig->GetValue( "RATE" );
+
+    DPRINTF(RubyMemory, "New memory request%7d: %#08x %c arrived at %lld\n",
+            m_msg_counter, (unsigned int)memRef.m_addr, memRef.m_is_mem_read ? 'R':'W',
+            memRef.m_time * g_system_ptr->clockPeriod());
+
+
+    // Build NVMainRequest and send to NVMain code.
+    NVMainRequest *request = (NVMainRequest *)memRef.m_metadata;
+    bool enqueued;
+    uint8_t *hostAddr;
+
+    Request *gem5Req = new Request( memRef.m_addr, transfer_size, 0, Request::funcMasterId );
+    Packet *gem5Pkt = new Packet( gem5Req, MemCmd::ReadReq );
+    gem5Pkt->allocate();
+    m_physMem->doFunctionalAccess( gem5Pkt );
+
+    hostAddr = new uint8_t[ transfer_size ];
+    memcpy( hostAddr, gem5Pkt->getPtr<uint8_t>(), gem5Pkt->getSize() );
+
+    //std::cout << "Memory req: " << std::hex << (unsigned int)memRef.m_addr << " "
+    //          << (memRef.m_is_mem_read ? 'R' : 'W') << " has data ";
+    //for(int i = 0; i < transfer_size; i++)
+    //  {
+    //    uint8_t byt = *(hostAddr + (transfer_size - 1) - i);
+    //
+    //    if( byt > 0xF )
+    //      std::cout << (int)byt;
+    //    else
+    //      std::cout << "0" << (int)byt;
+    //  }
+    //std::cout << std::dec << std::endl;
+
+    delete gem5Pkt;
+
+    request->access = UNKNOWN_ACCESS;
+    for(int i = 0; i < transfer_size; i++)
+    {
+        // memRef's m_msgptr's DataBlk is only correct for write data (since data is not read yet)
+        // However, nvmain needs data being read otherwise data is assumed 0 on first write, which
+        // may not be correct.
+        request->data.SetByte(i, *(hostAddr + (transfer_size - 1) - i));
+    }
+    request->address.SetPhysicalAddress(memRef.m_addr);
+    request->status = MEM_REQUEST_INCOMPLETE;
+    request->type = (memRef.m_is_mem_read) ? READ : WRITE;
+
+    //if(!memRef.m_is_mem_read)
+    //    std::cout << ((memRef.m_is_mem_read) ? "Read" : "Write") << " request for 0x"  << std::hex
+    //              << request->address.GetPhysicalAddress() << " has data " << request->data << std::endl;
+
+    //std::cout << "MemReq for 0x" << std::hex << request->address.GetPhysicalAddress( ) << " from PC "
+    //          << request->programCounter << " in core " << request->threadId << std::endl;
+
+    enqueued = m_nvmainPtr->NewRequest(request);
+    if(enqueued)
+    {
+            m_input_queue.push_back(memRef);
+        m_request_list.push_back(request);
+            m_slot_available = true;
+    }
+    else
+    {
+            m_slot_available = false;
+    }
+
+    // Schedule a wakeup.
+    //m_consumer_ptr->scheduleEvent( 1 );
+    if(!m_event.scheduled())
+    {
+        schedule(m_event, nextCycle());
+    }
+}
+
+void
+NVMainControl::dequeue()
+{
+    assert(isReady());
+    m_response_queue.pop_front();
+}
+
+const Message*
+NVMainControl::peek()
+{
+    MemoryNode node = peekNode();
+    Message* msg_ptr = node.m_msgptr.get();
+    assert(msg_ptr != NULL);
+    return msg_ptr;
+}
+
+MemoryNode
+NVMainControl::peekNode()
+{
+    assert(isReady());
+    MemoryNode req = m_response_queue.front();
+    DPRINTF(RubyMemory, "Peek: memory request%7d: %#08x %c\n",
+            req.m_msg_counter, req.m_addr, req.m_is_mem_read ? 'R':'W');
+
+    return req;
+}
+
+bool
+NVMainControl::isReady()
+{
+    bool rv;
+
+    rv = ((!m_response_queue.empty()) &&
+            (m_response_queue.front().m_time <= g_system_ptr->getTime()));
+
+    return rv;
+}
+
+void
+NVMainControl::setConsumer(Consumer* consumer_ptr)
+{
+    m_consumer_ptr = consumer_ptr;
+}
+
+void
+NVMainControl::print(std::ostream& out) const
+{
+}
+
+void
+NVMainControl::printConfig(std::ostream& out)
+{
+    out << "hai2u" << std::endl;
+}
+
+void
+NVMainControl::clearStats() const
+{
+    std::cout << "clearing stats in NVMainControl!!" << std::endl;
+}
+
+void
+NVMainControl::printStats(std::ostream& out) const
+{
+    std::cout << "printing stats from NVMainControl!!" << std::endl;
+}
+
+// Queue up a completed request to send back to directory
+void
+NVMainControl::enqueueToDirectory(MemoryNode req, int latency)
+{
+    Time arrival_time = g_system_ptr->getTime() + latency;
+    req.m_time = arrival_time;
+    m_response_queue.push_back(req);
+
+    DPRINTF(RubyMemory, "Enqueueing msg %#08x %c back to directory at %lld\n",
+            req.m_addr, req.m_is_mem_read ? 'R':'W',
+            arrival_time * g_system_ptr->clockPeriod());
+
+    //std::cout << "MemReq for 0x" << std::hex << req.m_addr << std::dec << " done." << std::endl;
+
+    // schedule the wake up
+    m_consumer_ptr->scheduleEventAbsolute(arrival_time);
+}
+
+
+bool
+NVMainControl::areNSlotsAvailable(int n)
+{
+    //std::cout << "NSlotsAvail called! Requests " << n << std::endl;
+    return m_nvmainPtr->CanIssue( NULL );
+    //return true;
+}
+
+
+bool
+NVMainControl::queueReady(int bank)
+{
+    return true;
+}
+
+
+void
+NVMainControl::issueRequest(int bank)
+{
+}
+
+void
+NVMainControl::executeCycle()
+{
+    m_nvmainPtr->Cycle( );
+}
+
+bool
+NVMainControl::functionalReadBuffers(Packet *pkt)
+{
+    /* We don't have access to the bank queues, but all requests
+     * sent to NVMain are in the input queue.
+     */
+    std::list<MemoryNode>::iterator it;
+
+    for( it = m_input_queue.begin(); it != m_input_queue.end(); it++ )
+    {
+        Message *msg_ptr = (*it).m_msgptr.get();
+        if (msg_ptr->functionalRead(pkt))
+        {
+            return true;
+        }
+    }
+
+    for( it = m_response_queue.begin(); it != m_response_queue.end(); it++ )
+    {
+        Message *msg_ptr = (*it).m_msgptr.get();
+        if (msg_ptr->functionalRead(pkt))
+        {
+            return true;
+        }
+    }
+
+    return false;
+}
+
+
+uint32_t
+NVMainControl::functionalWriteBuffers(Packet *pkt)
+{
+    uint32_t num_functional_writes = 0;
+    std::list<MemoryNode>::iterator it;
+
+    for( it = m_input_queue.begin(); it != m_input_queue.end(); it++ )
+    {
+        Message *msg_ptr = (*it).m_msgptr.get();
+        if (msg_ptr->functionalWrite(pkt))
+        {
+            num_functional_writes++;
+        }
+    }
+
+    for( it = m_response_queue.begin(); it != m_response_queue.end(); it++ )
+    {
+        Message *msg_ptr = (*it).m_msgptr.get();
+        if (msg_ptr->functionalWrite(pkt))
+        {
+            num_functional_writes++;
+        }
+    }
+
+    return false;
+}
+
+bool
+NVMainControl::RequestComplete(NVMainRequest *creq)
+{
+    // TODO: Make this an STL map instead to find in O(1)
+    std::list<MemoryNode>::iterator mit;
+
+    for(mit = m_input_queue.begin(); mit != m_input_queue.end(); mit++)
+    {
+        MemoryNode memRef = (*mit);
+
+        if(memRef.m_addr == creq->address.GetPhysicalAddress())
+        {
+            m_input_queue.erase( mit );
+            enqueueToDirectory( memRef, 1 );
+            break;
+        }
+    }
+
+    return true;
+}
+
+void
+NVMainControl::wakeup()
+{
+    executeCycle();
+
+    if(!m_event.scheduled())
+    {
+        schedule(m_event, nextCycle() + clock);
+    }
+}
+
+NVMainControl *
+NVMMemoryControlParams::create()
+{
+    return new NVMainControl(this);
+}
+
+
+
diff -r 8f1e524e3917 src/mem/ruby/system/NVMainControl.hh
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/mem/ruby/system/NVMainControl.hh	Tue Oct 16 16:15:04 2012 -0400
@@ -0,0 +1,162 @@
+/*
+ * Copyright (c) 1999-2008 Mark D. Hill and David A. Wood
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met: redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer;
+ * redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution;
+ * neither the name of the copyright holders nor the names of its
+ * contributors may be used to endorse or promote products derived from
+ * this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/*
+ *  This file is part of NVMain- A cycle accurate timing, bit-accurate
+ *  energy simulator for non-volatile memory. Originally developed by
+ *  Matt Poremba at the Pennsylvania State University.
+ *
+ *  Website: http://www.cse.psu.edu/~poremba/nvmain/
+ *  Email: mrp5060@psu.edu
+ *
+ *  ---------------------------------------------------------------------
+ *
+ *  If you use this software for publishable research, please include
+ *  the original NVMain paper in the citation list and mention the use
+ *  of NVMain.
+ *
+ */
+
+#ifndef __MEM_RUBY_SYSTEM_NVMAIN_CONTROL_HH__
+#define __MEM_RUBY_SYSTEM_NVMAIN_CONTROL_HH__
+
+#include <iostream>
+#include <list>
+#include <string>
+
+#include "NVM/nvmain.h"
+#include "base/callback.hh"
+#include "mem/protocol/MemoryMsg.hh"
+#include "mem/ruby/common/Address.hh"
+#include "mem/ruby/common/Consumer.hh"
+#include "mem/ruby/common/Global.hh"
+#include "mem/ruby/profiler/MemCntrlProfiler.hh"
+#include "mem/ruby/slicc_interface/Message.hh"
+#include "mem/ruby/system/MemoryNode.hh"
+#include "mem/ruby/system/System.hh"
+#include "mem/physical.hh"
+#include "params/NVMMemoryControl.hh"
+#include "sim/clocked_object.hh"
+#include "src/Config.h"
+#include "src/NVMObject.h"
+#include "src/SimInterface.h"
+
+class NVMainControl : public MemoryControl, public NVM::NVMObject
+{
+  public:
+    typedef NVMMemoryControlParams Params;
+    const Params *params() const
+    { return dynamic_cast<const Params *>(_params); }
+
+    NVMainControl(const Params *p);
+    void init();
+
+    ~NVMainControl();
+
+    void wakeup();
+
+    void setConsumer(Consumer* consumer_ptr);
+    Consumer* getConsumer() { return m_consumer_ptr; };
+    void setDescription(const std::string& name) { m_description = name; };
+    std::string getDescription() { return m_description; };
+
+    void enqueue(const MsgPtr& message, int latency );
+    void enqueueMemRef(MemoryNode& memRef);
+    void dequeue();
+    const Message* peek();
+    MemoryNode peekNode();
+    bool isReady();
+    bool areNSlotsAvailable(int n);
+
+
+    void printConfig(std::ostream& out);
+    void print(std::ostream& out) const;
+    void clearStats() const;
+    void printStats(std::ostream& out) const;
+
+
+    unsigned int drain(Event *de);
+
+    const int getRow(const physical_address_t) const;
+    const int getBank(const physical_address_t) const;
+    const int getRank(const physical_address_t) const;
+    const int getChannel(const physical_address_t) const;
+
+    int getBanksPerRank();
+    int getRanksPerDimm();
+    int getDimmsPerChannel();
+
+    bool functionalReadBuffers(Packet *pkt);
+    uint32_t functionalWriteBuffers(Packet *pkt);
+
+    void reset();
+    void Cycle() {}
+
+    bool RequestComplete(NVM::NVMainRequest *creq);
+
+  private:
+    class NVMainStatPrinter : public Callback
+    {
+      public:
+        void process() { if( nvmainPtr != NULL ) nvmainPtr->PrintStats( ); }
+
+        NVM::NVMain *nvmainPtr;
+    };
+
+
+    void enqueueToDirectory(MemoryNode req, int latency);
+    bool queueReady(int bank);
+    void issueRequest(int bank);
+    void executeCycle();
+
+    //NVMainControl (const NVMainControl& obj);
+    //NVMainControl& operator=(const NVMainControl& obj);
+
+    NVMainStatPrinter statPrinter;
+
+    Consumer* m_consumer_ptr;
+    std::string m_description;
+    int m_msg_counter;
+    int m_awakened;
+
+    bool m_slot_available;
+    bool m_nacked_requests;
+    NVM::NVMain *m_nvmainPtr;
+    SimpleMemory *m_physMem;
+    NVM::SimInterface *m_nvmainSimInterface;
+    NVM::Config *m_nvmainConfig;
+    std::string m_nvmainConfigPath;
+
+    std::list<MemoryNode> m_response_queue;
+    std::list<MemoryNode> m_input_queue;
+    std::list<MemoryNode>* m_bankQueues;
+
+    std::list<NVM::NVMainRequest *> m_request_list;
+};
+
+#endif // __MEM_RUBY_SYSTEM_NVMAIN_CONTROL_HH__
diff -r 8f1e524e3917 src/mem/ruby/system/NVMainControl.py
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/mem/ruby/system/NVMainControl.py	Tue Oct 16 16:15:04 2012 -0400
@@ -0,0 +1,41 @@
+# Copyright (c) 2009 Advanced Micro Devices, Inc.
+# All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions are
+# met: redistributions of source code must retain the above copyright
+# notice, this list of conditions and the following disclaimer;
+# redistributions in binary form must reproduce the above copyright
+# notice, this list of conditions and the following disclaimer in the
+# documentation and/or other materials provided with the distribution;
+# neither the name of the copyright holders nor the names of its
+# contributors may be used to endorse or promote products derived from
+# this software without specific prior written permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+#
+
+from m5.params import *
+from m5.SimObject import SimObject
+from MemoryControl import MemoryControl
+
+class NVMMemoryControl(MemoryControl):
+    type = 'NVMMemoryControl'
+    cxx_class = 'NVMainControl'
+    version = Param.Int("")
+    config = Param.String("NULL", "")
+    physicalMem = Param.SimpleMemory("")
+
+    configparams = Param.String("", "")
+    configvalues = Param.String("", "")
+
diff -r 8f1e524e3917 src/mem/ruby/system/SConscript
--- a/src/mem/ruby/system/SConscript	Tue Oct 16 15:24:06 2012 -0400
+++ b/src/mem/ruby/system/SConscript	Tue Oct 16 16:15:04 2012 -0400
@@ -37,6 +37,7 @@
 SimObject('Sequencer.py')
 SimObject('DirectoryMemory.py')
 SimObject('MemoryControl.py')
+SimObject('NVMainControl.py')
 SimObject('WireBuffer.py')
 SimObject('RubySystem.py')
 SimObject('RubyMemoryControl.py')
@@ -46,6 +47,7 @@
 Source('SparseMemory.cc')
 Source('CacheMemory.cc')
 Source('MemoryControl.cc')
+Source('NVMainControl.cc')
 Source('WireBuffer.cc')
 Source('RubyMemoryControl.cc')
 Source('MemoryNode.cc')
diff -r 8f1e524e3917 src/mem/simple_mem.hh
--- a/src/mem/simple_mem.hh	Tue Oct 16 15:24:06 2012 -0400
+++ b/src/mem/simple_mem.hh	Tue Oct 16 16:15:04 2012 -0400
@@ -129,7 +129,7 @@
                                         PortID idx = InvalidPortID);
     virtual void init();
 
-  protected:
+  //protected:
 
     Tick doAtomicAccess(PacketPtr pkt);
     void doFunctionalAccess(PacketPtr pkt);
diff -r 8f1e524e3917 src/mem/slicc/symbols/StateMachine.py
--- a/src/mem/slicc/symbols/StateMachine.py	Tue Oct 16 15:24:06 2012 -0400
+++ b/src/mem/slicc/symbols/StateMachine.py	Tue Oct 16 16:15:04 2012 -0400
@@ -40,6 +40,7 @@
                     "Sequencer": "RubySequencer",
                     "DirectoryMemory": "RubyDirectoryMemory",
                     "MemoryControl": "MemoryControl",
+                    "NVMainControl": "NVMMemoryControl",
                     "DMASequencer": "DMASequencer"
                     }
 
@@ -268,6 +269,7 @@
     void unblock(Address addr);
     void recordCacheTrace(int cntrl, CacheRecorder* tr);
     Sequencer* getSequencer() const;
+    CacheProfiler* getCacheProfiler() const;
 
     bool functionalReadBuffers(PacketPtr&);
     uint32_t functionalWriteBuffers(PacketPtr&);
@@ -720,6 +722,26 @@
     return $seq_ident;
 }
 
+
+CacheProfiler*
+$c_ident::getCacheProfiler() const
+{
+''')
+
+        code.indent()
+        foundCacheMemory = False
+        for param in self.config_parameters:
+            if param.type_ast.type.ident == "CacheMemory":
+                code('return m_${{param.ident}}_ptr->getCacheProfiler();')
+                foundCacheMemory = True
+                break
+
+        if foundCacheMemory == False:
+            code('return NULL;')
+
+        code.dedent()
+        code('''}
+
 const int &
 $c_ident::getVersion() const
 {
