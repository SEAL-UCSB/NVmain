# HG changeset patch
# Parent 3f6e2f267aba6571c478fcd83c4a1b9d6564084f

diff -r 3f6e2f267aba configs/common/Options.py
--- a/configs/common/Options.py	Mon Aug 26 10:58:06 2013 -0500
+++ b/configs/common/Options.py	Wed Aug 28 10:04:34 2013 -0400
@@ -198,6 +198,25 @@
         help="""Treat value of --checkpoint-restore or --take-checkpoint as a
                 number of instructions.""")
 
+    # Options for nvmain
+    parser.add_option("--nvmain-PARAM", type="string", default="NULL", help="Set NVMain configuration value for PARAM (e.g., --nvmain-RANKS=4, --nvmain-BANKS=8, etc.)") # Only provided for --help, does nothing
+    parser.add_option("--nvmain-warmup", action="store_true", help="Enable warm up of internal caches in NVMain (i.e., DRAMCaches, etc)")
+    parser.add_option("--nvmain-atomic", action="store_true", help="Enable NVMain when using the atomic CPU model.")
+    parser.add_option("--nvmain-atomic-latency", type="string", default="30ns", help="Specify the latency of memory requests in atomic mode")
+    parser.add_option("--nvmain-atomic-variance", type="string", default="5ns", help="Specify the variance of memory requests latencies in atomic mode")
+    parser.add_option("--nvmain-config", type="string", help="Specify the path to the NVMain configuration file")
+    parser.add_option("--no-nvmain", action="store_true", help="Don't use NVMain; Use the normal RubyMemoryControl")
+
+    #
+    #  Check for extra nvmain configuration override options and add them as options to python
+    #
+    nvmain_argnum = 1
+    for arg in sys.argv:
+        if arg[:9] == "--nvmain-" and arg != "--nvmain-warmup":
+            parser.add_option(arg, type="string", default="NULL", help="Set NVMain configuration value for a parameter")
+        nvmain_argnum = nvmain_argnum + 1
+
+
 def addSEOptions(parser):
     # Benchmark options
     parser.add_option("-c", "--cmd", default="",
diff -r 3f6e2f267aba configs/ruby/Ruby.py
--- a/configs/ruby/Ruby.py	Mon Aug 26 10:58:06 2013 -0500
+++ b/configs/ruby/Ruby.py	Wed Aug 28 10:04:34 2013 -0400
@@ -44,6 +44,86 @@
 from m5.objects import *
 from m5.defines import buildEnv
 
+import inspect
+from textwrap import TextWrapper
+
+RubyMemoryControl = None
+
+_ruby_mem_aliases_all = [
+    ("ruby", "RubyMemoryControl"),
+    ("nvmain", "NVMMemoryControl"),
+    ]
+
+_ruby_mem_classes = {}
+_ruby_mem_aliases = {}
+
+def is_ruby_mem_class(cls):
+    """Determine if a class is a memory controller that can be instantiated"""
+
+    # We can't use the normal inspect.isclass because the ParamFactory
+    # and ProxyFactory classes have a tendency to confuse it.
+    try:
+        return issubclass(cls, m5.objects.MemoryControl) and \
+            not cls.abstract
+    except TypeError:
+        return False
+
+# Add all memory controllers in the object hierarchy.
+for name, cls in inspect.getmembers(m5.objects, is_ruby_mem_class):
+    _ruby_mem_classes[name] = cls
+
+for alias, target in _ruby_mem_aliases_all:
+    if isinstance(target, tuple):
+        # Some aliases contain a list of CPU model sorted in priority
+        # order. Use the first target that's available.
+        for t in target:
+            if t in _ruby_mem_classes:
+                _ruby_mem_aliases[alias] = t
+                break
+    elif target in _ruby_mem_classes:
+        # Normal alias
+        _ruby_mem_aliases[alias] = target
+
+def ruby_mem_names():
+    """Return a list of valid CPU names."""
+    return _ruby_mem_classes.keys() + _ruby_mem_aliases.keys()
+
+def print_ruby_mem_list():
+    """Print a list of available memory classes including their aliases."""
+
+    print "Available memory classes:"
+    doc_wrapper = TextWrapper(initial_indent="\t\t", subsequent_indent="\t\t")
+    for name, cls in _ruby_mem_classes.items():
+        print "\t%s" % name
+
+        # Try to extract the class documentation from the class help
+        # string.
+        doc = inspect.getdoc(cls)
+        if doc:
+            for line in doc_wrapper.wrap(doc):
+                print line
+
+    if _ruby_mem_aliases:
+        print "\nMemory aliases:"
+        for alias, target in _ruby_mem_aliases.items():
+            print "\t%s => %s" % (alias, target)
+
+def get_ruby_mem_class(name):
+    """Get a memory class from a user provided class name or alias."""
+
+    real_name = _ruby_mem_aliases.get(name, name)
+
+    try:
+        ruby_mem_class = _ruby_mem_classes[real_name]
+        return ruby_mem_class
+    except KeyError:
+        print "%s is not a valid memory controller." % (name,)
+        sys.exit(1)
+
+def _listRubyMemTypes(option, opt, value, parser):
+    print_ruby_mem_list()
+    sys.exit(0)
+
 def define_options(parser):
     # By default, ruby uses the simple timing cpu
     parser.set_defaults(cpu_type="timing")
@@ -72,6 +152,14 @@
                       help="high order address bit to use for numa mapping. " \
                            "0 = highest bit, not specified = lowest bit")
 
+    # memory controller options
+    parser.add_option("--ruby-mem-type", type="choice", default="nvmain",
+                      choices=ruby_mem_names(),
+                      help = "type of memory to use with ruby")
+    parser.add_option("--list-ruby-mem-types",
+                      action="callback", callback=_listRubyMemTypes,
+                      help="List available memory types")
+
     # ruby sparse memory options
     parser.add_option("--use-map", action="store_true", default=False)
     parser.add_option("--map-levels", type="int", default=4)
@@ -114,6 +202,15 @@
         print "Error: could not create sytem for ruby protocol %s" % protocol
         raise
 
+    # Override the memBuffer for each directory.
+    for i in xrange(options.num_dirs):
+        print "Changing memory type to %s" % options.ruby_mem_type
+        mem_cntrl_class = get_ruby_mem_class(options.ruby_mem_type)
+        new_mem_cntrl = mem_cntrl_class(version = i, ruby_system = ruby)
+        ruby.no_mem_vec = False
+
+        exec("ruby.dir_cntrl%d.memBuffer = new_mem_cntrl" % i)
+
     # Create a port proxy for connecting the system port. This is
     # independent of the protocol and kept in the protocol-agnostic
     # part (i.e. here).
diff -r 3f6e2f267aba src/mem/ruby/system/NVMainControl.cc
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/mem/ruby/system/NVMainControl.cc	Wed Aug 28 10:04:34 2013 -0400
@@ -0,0 +1,566 @@
+/*
+ * Copyright (c) 1999-2008 Mark D. Hill and David A. Wood
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met: redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer;
+ * redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution;
+ * neither the name of the copyright holders nor the names of its
+ * contributors may be used to endorse or promote products derived from
+ * this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/*******************************************************************************
+* Copyright (c) 2012-2013, The Microsystems Design Labratory (MDL)
+* Department of Computer Science and Engineering, The Pennsylvania State University
+* All rights reserved.
+*
+* This source code is part of NVMain - A cycle accurate timing, bit accurate
+* energy simulator for both volatile (e.g., DRAM) and nono-volatile memory
+* (e.g., PCRAM). The source code is free and you can redistribute and/or
+* modify it by providing that the following conditions are met:
+*
+*  1) Redistributions of source code must retain the above copyright notice,
+*     this list of conditions and the following disclaimer.
+*
+*  2) Redistributions in binary form must reproduce the above copyright notice,
+*     this list of conditions and the following disclaimer in the documentation
+*     and/or other materials provided with the distribution.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+* ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+* DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+* FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+* DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+* SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+* CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+* OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+* OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*
+* Author list:
+*   Matt Poremba    ( Email: mrp5060 at psu dot edu
+*                     Website: http://www.cse.psu.edu/~poremba/ )
+*******************************************************************************/
+
+#include "SimInterface/NullInterface/NullInterface.h"
+#include "Utils/HookFactory.h"
+#include "base/cprintf.hh"
+#include "mem/ruby/common/Address.hh"
+#include "mem/ruby/common/Consumer.hh"
+#include "mem/ruby/common/Global.hh"
+#include "mem/ruby/network/Network.hh"
+#include "mem/ruby/profiler/Profiler.hh"
+#include "mem/ruby/slicc_interface/NetworkMessage.hh"
+#include "mem/ruby/slicc_interface/RubySlicc_ComponentMapping.hh"
+#include "mem/ruby/system/NVMainControl.hh"
+#include "mem/ruby/system/System.hh"
+#include "mem/packet.hh"
+#include "mem/request.hh"
+#include "mem/simple_mem.hh"
+
+using namespace NVM;
+
+class Consumer;
+
+
+
+NVMainControl::NVMainControl(const Params *p)
+    : MemoryControl(p)
+{
+    char *cfgparams;
+    char *cfgvalues;
+    char *cparam, *cvalue;
+
+    char *saveptr1, *saveptr2;
+
+    m_nvmainPtr = NULL;
+    m_slot_available = true;
+    m_retryRequest = NULL;
+
+    m_nvmainConfigPath = p->config;
+
+    m_nvmainConfig = new Config( );
+
+    m_nvmainConfig->Read( m_nvmainConfigPath );
+    std::cout << "NVMainControl: Reading NVMain config file: " << m_nvmainConfigPath << "." << std::endl;
+
+    /* Override any parameters specified on the command line. */
+    cfgparams = (char *)p->configparams.c_str();
+    cfgvalues = (char *)p->configvalues.c_str();
+
+    for( cparam = strtok_r( cfgparams, ",", &saveptr1 ), cvalue = strtok_r( cfgvalues, ",", &saveptr2 )
+           ; (cparam && cvalue) ; cparam = strtok_r( NULL, ",", &saveptr1 ), cvalue = strtok_r( NULL, ",", &saveptr2) )
+    {
+        std::cout << "NVMain: Overriding parameter `" << cparam << "' with `" << cvalue << "'" << std::endl;
+        m_nvmainConfig->SetValue( cparam, cvalue );
+    }
+
+    m_BusWidth = m_nvmainConfig->GetValue( "BusWidth" );
+    m_tBURST = m_nvmainConfig->GetValue( "tBURST" );
+    m_RATE = m_nvmainConfig->GetValue( "RATE" );
+
+    m_banks = m_nvmainConfig->GetValue( "BANKS" );
+    m_ranks = m_nvmainConfig->GetValue( "RANKS" );
+    m_ranksPerDimm = (m_nvmainConfig->KeyExists( "RanksPerDIMM" ) ? m_nvmainConfig->GetValue( "RanksPerDIMM" ) : 1);
+}
+
+void
+NVMainControl::init()
+{
+    m_nvmainPtr = new NVMain( );
+    m_nvmainSimInterface = new NullInterface( );
+    m_nvmainEventQueue = new NVM::EventQueue( );
+
+    m_nvmainConfig->SetSimInterface( m_nvmainSimInterface );
+
+    statPrinter.nvmainPtr = m_nvmainPtr;
+    registerExitCallback( &statPrinter );
+
+    SetEventQueue( m_nvmainEventQueue );
+
+    /*  Add any specified hooks */
+    std::vector<std::string>& hookList = m_nvmainConfig->GetHooks( );
+
+    for( size_t i = 0; i < hookList.size( ); i++ )
+    {
+        std::cout << "Creating hook " << hookList[i] << std::endl;
+
+        NVMObject *hook = HookFactory::CreateHook( hookList[i] );
+
+        if( hook != NULL )
+        {
+            AddHook( hook );
+            hook->SetParent( this );
+            hook->Init( m_nvmainConfig );
+        }
+        else
+        {
+            std::cout << "Warning: Could not create a hook named `"
+                << hookList[i] << "'." << std::endl;
+        }
+    }
+
+    /* Setup child and parent modules */
+    AddChild( m_nvmainPtr );
+    m_nvmainPtr->SetParent( this );
+
+    m_nvmainPtr->SetConfig( m_nvmainConfig );
+}
+
+NVMainControl::~NVMainControl()
+{
+    delete m_nvmainPtr;
+    delete m_nvmainSimInterface;
+    delete m_nvmainEventQueue;
+    delete m_nvmainConfig;
+}
+
+// Not used.
+const int
+NVMainControl::getRow(const physical_address_t) const
+{
+    return -1;
+}
+
+// Not used.
+const int
+NVMainControl::getRank(const physical_address_t) const
+{
+    return -1;
+}
+
+// Not used.
+const int
+NVMainControl::getBank(const physical_address_t) const
+{
+    return -1;
+}
+
+// Not used.
+const int
+NVMainControl::getChannel(const physical_address_t) const
+{
+    return -1;
+}
+
+int
+NVMainControl::getBanksPerRank()
+{
+    return m_banks;
+}
+
+int
+NVMainControl::getRanksPerDimm()
+{
+    return m_ranksPerDimm;
+}
+
+int
+NVMainControl::getDimmsPerChannel()
+{
+    return (m_ranks / m_ranksPerDimm);
+}
+
+void
+NVMainControl::reset()
+{
+    // This is meant to reset memory controller settings, i.e. round robin
+    // counters, statistics, etc.
+    //
+    // TODO: Is this ever called ?
+}
+
+unsigned int
+NVMainControl::drain(DrainManager *)
+{
+    DPRINTF(RubyMemory, "MemoryController drain\n");
+    if(m_event.scheduled()) {
+        deschedule(m_event);
+    }
+    return 0;
+}
+
+void
+NVMainControl::enqueue(const MsgPtr& message, Cycles latency)
+{
+    Cycles arrival_time = curCycle() + latency;
+
+    const MemoryMsg* memMess = safe_cast<const MemoryMsg*>(message.get());
+    physical_address_t addr = memMess->getAddr().getAddress();
+    MemoryRequestType type = memMess->getType();
+    bool is_mem_read = (type == MemoryRequestType_MEMORY_READ);
+
+    MemoryNode thisReq(arrival_time, message, addr, is_mem_read, !is_mem_read);
+    enqueueMemRef(thisReq);
+}
+
+void
+NVMainControl::enqueueMemRef(MemoryNode& memRef)
+{
+    m_msg_counter++;
+    memRef.m_msg_counter = m_msg_counter;
+    int transfer_size;
+
+    transfer_size = m_BusWidth / 8;
+    transfer_size *= m_tBURST * m_RATE;
+
+    DPRINTF(RubyMemory, "New memory request%7d: %#08x %c arrived at %lld\n",
+            m_msg_counter, (unsigned int)memRef.m_addr, memRef.m_is_mem_read ? 'R':'W',
+            memRef.m_time * g_system_ptr->clockPeriod());
+
+
+    // Build NVMainRequest and send to NVMain code.
+    NVMainRequest *request = new NVMainRequest( );
+    bool enqueued;
+    uint8_t *hostAddr;
+    Address freadAddr( memRef.m_addr );
+
+    hostAddr = new uint8_t[ transfer_size ];
+
+    // Note: If you need memory data (for endurance modeling), make sure options.use_map is False
+    if( g_system_ptr->getMemoryVector() != NULL )
+        (void)g_system_ptr->getMemoryVector()->read( freadAddr, hostAddr, transfer_size );
+    else
+        memset( hostAddr, 0, transfer_size );
+
+    // Uncomment this to test that memory data is correct
+    //std::cout << "Memory req: " << std::hex << (unsigned int)memRef.m_addr << " "
+    //          << (memRef.m_is_mem_read ? 'R' : 'W') << " has data ";
+    //for(int i = 0; i < transfer_size; i++)
+    //  {
+    //    uint8_t byt = *(hostAddr + (transfer_size - 1) - i);
+    //
+    //    if( byt > 0xF )
+    //      std::cout << (int)byt;
+    //    else
+    //      std::cout << "0" << (int)byt;
+    //  }
+    //std::cout << std::dec << std::endl;
+
+    request->access = UNKNOWN_ACCESS;
+    for(int i = 0; i < transfer_size; i++)
+    {
+        // memRef's m_msgptr's DataBlk is only correct for write data (since data is not read yet)
+        // However, nvmain needs data being read otherwise data is assumed 0 on first write, which
+        // may not be correct.
+        request->data.SetByte(i, *(hostAddr + (transfer_size - 1) - i));
+    }
+    request->address.SetPhysicalAddress(memRef.m_addr);
+    request->status = MEM_REQUEST_INCOMPLETE;
+    request->type = (memRef.m_is_mem_read) ? READ : WRITE;
+
+    if( !m_slot_available )
+    {
+        DPRINTF(RubyMemory, "enqueueMemRef: No slots available, but got request for address 0x%X\n",
+                memRef.m_addr);
+    }
+
+    enqueued = m_nvmainPtr->IssueCommand(request);
+    if(enqueued)
+    {
+        m_input_queue.push_back(memRef);
+        m_slot_available = true;
+    }
+    else
+    {
+        m_slot_available = false;
+        std::cout << "Could not issue request for address 0x" << std::hex << memRef.m_addr << std::dec << std::endl;
+
+        assert( m_retryRequest == NULL );
+        assert( m_retryRefs.empty() );
+
+        m_retryRequest = request;
+
+        /*
+         *  This seems a bit idiotic to use a list that will only ever have one item.
+         *  MemoryNode has no default ctor, so it can't be on the stack, and there is
+         *  an issue related to ref counting if it's a pointer. We will just use a list
+         *  and assume future support for checking the queue in NVMain and adding more
+         *  elements to this list.
+         */
+        m_retryRefs.push_back( memRef );
+    }
+
+    // Schedule a wakeup.
+    if(!m_event.scheduled())
+    {
+        schedule(m_event, nextCycle());
+    }
+}
+
+void
+NVMainControl::dequeue()
+{
+    assert(isReady());
+    m_response_queue.pop_front();
+}
+
+const Message*
+NVMainControl::peek()
+{
+    MemoryNode node = peekNode();
+    Message* msg_ptr = node.m_msgptr.get();
+    assert(msg_ptr != NULL);
+    return msg_ptr;
+}
+
+MemoryNode
+NVMainControl::peekNode()
+{
+    assert(isReady());
+    MemoryNode req = m_response_queue.front();
+    DPRINTF(RubyMemory, "Peek: memory request%7d: %#08x %c\n",
+            req.m_msg_counter, req.m_addr, req.m_is_mem_read ? 'R':'W');
+
+    return req;
+}
+
+bool
+NVMainControl::isReady()
+{
+    bool rv;
+
+    rv = ((!m_response_queue.empty()) &&
+            (m_response_queue.front().m_time <= g_system_ptr->curCycle()));
+
+    return rv;
+}
+
+void
+NVMainControl::setConsumer(Consumer* consumer_ptr)
+{
+    m_consumer_ptr = consumer_ptr;
+}
+
+void
+NVMainControl::print(std::ostream& out) const
+{
+}
+
+void
+NVMainControl::clearStats() const
+{
+}
+
+void
+NVMainControl::printStats(std::ostream& out) const
+{
+    m_nvmainPtr->PrintStats( );
+}
+
+// Queue up a completed request to send back to directory
+void
+NVMainControl::enqueueToDirectory(MemoryNode req, Cycles latency)
+{
+    Time arrival_time = clockEdge(latency);
+    Cycles ruby_arrival_time = g_system_ptr->ticksToCycles(arrival_time);
+    req.m_time = ruby_arrival_time;
+    m_response_queue.push_back(req);
+
+    DPRINTF(RubyMemory, "Enqueueing msg %#08x %c back to directory at %lld\n",
+            req.m_addr, req.m_is_mem_read ? 'R':'W',
+            arrival_time * g_system_ptr->clockPeriod());
+
+    // schedule the wake up
+    m_consumer_ptr->scheduleEventAbsolute(arrival_time);
+}
+
+
+bool
+NVMainControl::areNSlotsAvailable(int n)
+{
+    // TODO: When is n>1? Currently there is no interface to ask the
+    // memory controller how many slots are in the queue.
+    return m_slot_available;
+}
+
+
+void
+NVMainControl::executeCycle()
+{
+    m_nvmainPtr->Cycle( 1 );
+}
+
+bool
+NVMainControl::functionalReadBuffers(Packet *pkt)
+{
+    /* We don't have access to the bank queues, but all requests
+     * sent to NVMain are in the input queue.
+     */
+    std::list<MemoryNode>::iterator it;
+
+    for( it = m_input_queue.begin(); it != m_input_queue.end(); it++ )
+    {
+        Message *msg_ptr = (*it).m_msgptr.get();
+        if (msg_ptr->functionalRead(pkt))
+        {
+            return true;
+        }
+    }
+
+    for( it = m_response_queue.begin(); it != m_response_queue.end(); it++ )
+    {
+        Message *msg_ptr = (*it).m_msgptr.get();
+        if (msg_ptr->functionalRead(pkt))
+        {
+            return true;
+        }
+    }
+
+    return false;
+}
+
+
+uint32_t
+NVMainControl::functionalWriteBuffers(Packet *pkt)
+{
+    uint32_t num_functional_writes = 0;
+    std::list<MemoryNode>::iterator it;
+
+    for( it = m_input_queue.begin(); it != m_input_queue.end(); it++ )
+    {
+        Message *msg_ptr = (*it).m_msgptr.get();
+        if (msg_ptr->functionalWrite(pkt))
+        {
+            num_functional_writes++;
+        }
+    }
+
+    for( it = m_response_queue.begin(); it != m_response_queue.end(); it++ )
+    {
+        Message *msg_ptr = (*it).m_msgptr.get();
+        if (msg_ptr->functionalWrite(pkt))
+        {
+            num_functional_writes++;
+        }
+    }
+
+    return false;
+}
+
+bool
+NVMainControl::RequestComplete(NVMainRequest *creq)
+{
+    // TODO: Make this an STL map instead to find in O(1)
+    std::list<MemoryNode>::iterator mit;
+
+    for(mit = m_input_queue.begin(); mit != m_input_queue.end(); mit++)
+    {
+        MemoryNode memRef = (*mit);
+
+        if(memRef.m_addr == creq->address.GetPhysicalAddress())
+        {
+            m_input_queue.erase( mit );
+            enqueueToDirectory( memRef, Cycles(1) );
+            break;
+        }
+    }
+
+    // Assume there is now a slot since a request is complete
+    m_slot_available = true;
+
+    if( m_retryRequest != NULL )
+    {
+        DPRINTF(RubyMemory, "RequestComplete: Attempting to re-issue request for 0x%X\n",
+                m_retryRequest->address.GetPhysicalAddress());
+
+        bool enqueued = m_nvmainPtr->IssueCommand(m_retryRequest);
+
+        if(enqueued)
+        {
+            m_input_queue.push_back(m_retryRefs.front());
+            m_slot_available = true;
+
+            m_retryRefs.clear( );
+            m_retryRequest = NULL;
+        }
+        else
+        {
+            // If the request doesn't retry, the simulator will probably deadlock
+            // (since there may be no more requests completing). Based on tests,
+            // the hasn't happened.
+            m_slot_available = false;
+            DPRINTF(RubyMemory, "RequestComplete: Could not issue retry request for address 0x%X\n",
+                    m_retryRequest->address.GetPhysicalAddress());
+        }
+    }
+
+    return true;
+}
+
+void
+NVMainControl::wakeup()
+{
+    executeCycle();
+
+    if(!m_event.scheduled())
+    {
+        schedule(m_event, clockEdge(Cycles(1)));
+    }
+}
+
+NVMainControl *
+NVMMemoryControlParams::create()
+{
+    return new NVMainControl(this);
+}
+
+
+
diff -r 3f6e2f267aba src/mem/ruby/system/NVMainControl.hh
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/mem/ruby/system/NVMainControl.hh	Wed Aug 28 10:04:34 2013 -0400
@@ -0,0 +1,180 @@
+/*
+ * Copyright (c) 1999-2008 Mark D. Hill and David A. Wood
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met: redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer;
+ * redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution;
+ * neither the name of the copyright holders nor the names of its
+ * contributors may be used to endorse or promote products derived from
+ * this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/*******************************************************************************
+* Copyright (c) 2012-2013, The Microsystems Design Labratory (MDL)
+* Department of Computer Science and Engineering, The Pennsylvania State University
+* All rights reserved.
+*
+* This source code is part of NVMain - A cycle accurate timing, bit accurate
+* energy simulator for both volatile (e.g., DRAM) and nono-volatile memory
+* (e.g., PCRAM). The source code is free and you can redistribute and/or
+* modify it by providing that the following conditions are met:
+*
+*  1) Redistributions of source code must retain the above copyright notice,
+*     this list of conditions and the following disclaimer.
+*
+*  2) Redistributions in binary form must reproduce the above copyright notice,
+*     this list of conditions and the following disclaimer in the documentation
+*     and/or other materials provided with the distribution.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+* ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+* DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+* FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+* DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+* SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+* CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+* OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+* OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*
+* Author list:
+*   Matt Poremba    ( Email: mrp5060 at psu dot edu
+*                     Website: http://www.cse.psu.edu/~poremba/ )
+*******************************************************************************/
+
+#ifndef __MEM_RUBY_SYSTEM_NVMAIN_CONTROL_HH__
+#define __MEM_RUBY_SYSTEM_NVMAIN_CONTROL_HH__
+
+#include <iostream>
+#include <list>
+#include <string>
+
+#include "NVM/nvmain.h"
+#include "base/callback.hh"
+#include "include/NVMainRequest.h"
+#include "mem/protocol/MemoryMsg.hh"
+#include "mem/ruby/common/Address.hh"
+#include "mem/ruby/common/Consumer.hh"
+#include "mem/ruby/common/Global.hh"
+#include "mem/ruby/profiler/MemCntrlProfiler.hh"
+#include "mem/ruby/slicc_interface/Message.hh"
+#include "mem/ruby/system/MemoryControl.hh"
+#include "mem/ruby/system/MemoryNode.hh"
+#include "mem/ruby/system/System.hh"
+#include "mem/physical.hh"
+#include "params/NVMMemoryControl.hh"
+#include "sim/clocked_object.hh"
+#include "src/Config.h"
+#include "src/EventQueue.h"
+#include "src/NVMObject.h"
+#include "src/SimInterface.h"
+
+class NVMainControl : public MemoryControl, public NVM::NVMObject
+{
+  public:
+    typedef NVMMemoryControlParams Params;
+
+    NVMainControl(const Params *p);
+    void init();
+
+    ~NVMainControl();
+
+    void wakeup();
+
+    void setConsumer(Consumer* consumer_ptr);
+    Consumer* getConsumer() { return m_consumer_ptr; };
+    void setDescription(const std::string& name) { m_description = name; };
+    std::string getDescription() { return m_description; };
+
+    void enqueue(const MsgPtr& message, Cycles latency );
+    void enqueueMemRef(MemoryNode& memRef);
+    void dequeue();
+    const Message* peek();
+    MemoryNode peekNode();
+    bool isReady();
+    bool areNSlotsAvailable(int n);
+
+    void print(std::ostream& out) const;
+    void clearStats() const;
+    void printStats(std::ostream& out) const;
+
+
+    unsigned int drain(DrainManager *dm);
+
+    const int getRow(const physical_address_t) const;
+    const int getBank(const physical_address_t) const;
+    const int getRank(const physical_address_t) const;
+    const int getChannel(const physical_address_t) const;
+
+    int getBanksPerRank();
+    int getRanksPerDimm();
+    int getDimmsPerChannel();
+
+    bool functionalReadBuffers(Packet *pkt);
+    uint32_t functionalWriteBuffers(Packet *pkt);
+
+    void reset();
+    void Cycle(NVM::ncycle_t) {}
+
+    bool RequestComplete(NVM::NVMainRequest *creq);
+
+  private:
+    class NVMainStatPrinter : public Callback
+    {
+      public:
+        void process() { if( nvmainPtr != NULL ) nvmainPtr->PrintStats( ); }
+
+        NVM::NVMain *nvmainPtr;
+    };
+
+
+    void enqueueToDirectory(MemoryNode req, Cycles latency);
+    void executeCycle();
+
+    NVM::NVMainRequest *m_retryRequest;
+    std::list<MemoryNode> m_retryRefs;
+
+    //NVMainControl (const NVMainControl& obj);
+    //NVMainControl& operator=(const NVMainControl& obj);
+
+    NVMainStatPrinter statPrinter;
+
+    Consumer* m_consumer_ptr;
+    std::string m_description;
+    int m_msg_counter;
+    int m_awakened;
+
+    int m_BusWidth, m_tBURST, m_RATE;
+    int m_banks, m_ranks, m_ranksPerDimm;
+
+    bool m_slot_available;
+    NVM::NVMain *m_nvmainPtr;
+    NVM::SimInterface *m_nvmainSimInterface;
+    NVM::Config *m_nvmainConfig;
+    NVM::EventQueue *m_nvmainEventQueue;
+    std::string m_nvmainConfigPath;
+
+    std::list<MemoryNode> m_response_queue;
+    std::list<MemoryNode> m_input_queue;
+    std::list<MemoryNode>* m_bankQueues;
+
+};
+
+#endif // __MEM_RUBY_SYSTEM_NVMAIN_CONTROL_HH__
diff -r 3f6e2f267aba src/mem/ruby/system/NVMainControl.py
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/mem/ruby/system/NVMainControl.py	Wed Aug 28 10:04:34 2013 -0400
@@ -0,0 +1,72 @@
+# Copyright (c) 2009 Advanced Micro Devices, Inc.
+# All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions are
+# met: redistributions of source code must retain the above copyright
+# notice, this list of conditions and the following disclaimer;
+# redistributions in binary form must reproduce the above copyright
+# notice, this list of conditions and the following disclaimer in the
+# documentation and/or other materials provided with the distribution;
+# neither the name of the copyright holders nor the names of its
+# contributors may be used to endorse or promote products derived from
+# this software without specific prior written permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+#
+
+import sys
+
+from m5.params import *
+from m5.SimObject import SimObject
+from MemoryControl import MemoryControl
+
+class NVMMemoryControl(MemoryControl):
+    type = 'NVMMemoryControl'
+    cxx_class = 'NVMainControl'
+    cxx_header = "mem/ruby/system/NVMainControl.hh"
+
+    version = Param.Int("")
+    config = Param.String("NULL", "")
+
+    configparams = Param.String("", "")
+    configvalues = Param.String("", "")
+
+    def __init__(self, *args, **kwargs):
+        MemoryControl.__init__(self, *args, **kwargs)
+
+        config_params = ""
+        config_values = ""
+
+        for arg in sys.argv:
+            if arg[:9] == "--nvmain-":
+                param_pair = arg.split('=', 1)
+                param_name = (param_pair[0])[9:]
+                param_value = param_pair[1]
+
+                # Handle special cases
+                if param_name == "config":
+                    self.config = param_value
+                else:
+                    print "Setting %s to %s" % (param_name, param_value)
+                    if config_params == "":
+                        config_params = param_name
+                    else:
+                        config_params = config_params + "," + param_name
+                    if config_values == "":
+                        config_values += param_value
+                    else:
+                        config_values = config_values + "," + param_value
+
+        self.configparams = config_params
+        self.configvalues = config_values
diff -r 3f6e2f267aba src/mem/ruby/system/SConscript
--- a/src/mem/ruby/system/SConscript	Mon Aug 26 10:58:06 2013 -0500
+++ b/src/mem/ruby/system/SConscript	Wed Aug 28 10:04:34 2013 -0400
@@ -40,6 +40,7 @@
 SimObject('WireBuffer.py')
 SimObject('RubySystem.py')
 SimObject('RubyMemoryControl.py')
+SimObject('NVMainControl.py')
 
 Source('DMASequencer.cc')
 Source('DirectoryMemory.cc')
@@ -48,6 +49,7 @@
 Source('MemoryControl.cc')
 Source('WireBuffer.cc')
 Source('RubyMemoryControl.cc')
+Source('NVMainControl.cc')
 Source('MemoryNode.cc')
 Source('PersistentTable.cc')
 Source('RubyPort.cc')
