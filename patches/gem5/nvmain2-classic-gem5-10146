# HG changeset patch
# Parent 62ea1e981b060a063e8a9ebec46e6e3894e5c829
Fix having multiple instances of NVMainMemory, such as X86 with more than 3GB of memory

diff -r 62ea1e981b06 configs/common/MemConfig.py
--- a/configs/common/MemConfig.py	Tue Jun 10 19:01:06 2014 -0400
+++ b/configs/common/MemConfig.py	Fri Jun 13 18:21:07 2014 -0400
@@ -49,6 +49,7 @@
 # fina; list. A target may be specified as a tuple, in which case the
 # first available memory controller model in the tuple will be used.
 _mem_aliases_all = [
+    ("nvmain", "NVMainMemory"),
     ("simple_mem", "SimpleMemory"),
     ("ddr3_1600_x64", "DDR3_1600_x64"),
     ("lpddr2_s4_1066_x32", "LPDDR2_S4_1066_x32"),
diff -r 62ea1e981b06 configs/common/Options.py
--- a/configs/common/Options.py	Tue Jun 10 19:01:06 2014 -0400
+++ b/configs/common/Options.py	Fri Jun 13 18:21:07 2014 -0400
@@ -211,6 +211,24 @@
                       help="ARM instruction set.")
 
 
+    # Options for nvmain
+    parser.add_option("--nvmain-PARAM", type="string", default="NULL", help="Set NVMain configuration value for PARAM (e.g., --nvmain-RANKS=4, --nvmain-BANKS=8, etc.)") # Only provided for --help, does nothing
+    parser.add_option("--nvmain-warmup", action="store_true", help="Enable warm up of internal caches in NVMain (i.e., DRAMCaches, etc)")
+    parser.add_option("--nvmain-atomic", action="store_true", help="Enable NVMain when using the atomic CPU model.")
+    parser.add_option("--nvmain-atomic-latency", type="string", default="30ns", help="Specify the latency of memory requests in atomic mode")
+    parser.add_option("--nvmain-atomic-variance", type="string", default="5ns", help="Specify the variance of memory requests latencies in atomic mode")
+    parser.add_option("--nvmain-config", type="string", help="Specify the path to the NVMain configuration file")
+
+    #
+    #  Check for extra nvmain configuration override options and add them as options to python
+    #
+    nvmain_argnum = 1
+    for arg in sys.argv:
+        if arg[:9] == "--nvmain-" and arg != "--nvmain-warmup":
+            parser.add_option(arg, type="string", default="NULL", help="Set NVMain configuration value for a parameter")
+        nvmain_argnum = nvmain_argnum + 1
+
+
 def addSEOptions(parser):
     # Benchmark options
     parser.add_option("-c", "--cmd", default="",
diff -r 62ea1e981b06 src/mem/NVMainMemory.py
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/mem/NVMainMemory.py	Fri Jun 13 18:21:07 2014 -0400
@@ -0,0 +1,90 @@
+# Copyright (c) 2012-2013 Pennsylvania State University
+# All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions are
+# met: redistributions of source code must retain the above copyright
+# notice, this list of conditions and the following disclaimer;
+# redistributions in binary form must reproduce the above copyright
+# notice, this list of conditions and the following disclaimer in the
+# documentation and/or other materials provided with the distribution;
+# neither the name of the copyright holders nor the names of its
+# contributors may be used to endorse or promote products derived from
+# this software without specific prior written permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+#
+# Authors: Matt Poremba
+#          Tao Zhang
+
+import optparse
+import sys
+
+from m5.params import *
+from AbstractMemory import *
+from ClockDomain import *
+
+class NVMainMemory(AbstractMemory):
+    type = 'NVMainMemory'
+    cxx_header = 'mem/nvmain_mem.hh'
+    port = SlavePort("Slave ports")
+    atomic_mode = Param.Bool(False, "Enable to use NVMain in atomic mode rather than latency/variance")
+    atomic_latency = Param.Latency('30ns', "Request latency in atomic mode")
+    atomic_variance = Param.Latency('30ns', "Request latency in atomic mode")
+
+    config = Param.String("", "")
+    configparams = Param.String("", "")
+    configvalues = Param.String("", "")
+    NVMainWarmUp = Param.Bool(False, "Enable to warm up the internal cache in NVMain")
+
+
+    def __init__(self, *args, **kwargs):
+        AbstractMemory.__init__(self, *args, **kwargs)
+
+        config_params = ""
+        config_values = ""
+
+        for arg in sys.argv:
+            if arg[:9] == "--nvmain-":
+                param_pair = arg.split('=', 1)
+                param_name = (param_pair[0])[9:]
+                if len(param_pair) > 1:
+                    param_value = param_pair[1]
+                else:
+                    param_value = ""
+
+                # Handle special cases
+                if param_name == "atomic":
+                    self.atomic_mode = True
+                elif param_name == "atomic-latency":
+                    self.atomic_latency = param_value
+                elif param_name == "atomic-variance":
+                    self.atomic_variance = param_value
+                elif param_name == "warmup":
+                    self.NVMainWarmUp = True
+                elif param_name == "config":
+                    self.config = param_value
+                else:
+                    print "Setting %s to %s" % (param_name, param_value)
+                    if config_params == "":
+                        config_params = param_name
+                    else:
+                        config_params = config_params + "," + param_name
+                    if config_values == "":
+                        config_values += param_value
+                    else:
+                        config_values = config_values + "," + param_value
+
+        self.configparams = config_params
+        self.configvalues = config_values
+
diff -r 62ea1e981b06 src/mem/SConscript
--- a/src/mem/SConscript	Tue Jun 10 19:01:06 2014 -0400
+++ b/src/mem/SConscript	Fri Jun 13 18:21:07 2014 -0400
@@ -43,6 +43,7 @@
 SimObject('DRAMCtrl.py')
 SimObject('MemObject.py')
 SimObject('SimpleMemory.py')
+SimObject('NVMainMemory.py')
 
 Source('abstract_mem.cc')
 Source('addr_mapper.cc')
@@ -59,6 +60,7 @@
 Source('tport.cc')
 Source('port_proxy.cc')
 Source('simple_mem.cc')
+Source('nvmain_mem.cc')
 Source('physical.cc')
 
 if env['TARGET_ISA'] != 'null':
@@ -86,5 +88,7 @@
 DebugFlag('MMU')
 DebugFlag('MemoryAccess')
 DebugFlag('PacketQueue')
+DebugFlag('NVMain')
+DebugFlag('NVMainMin')
 
 DebugFlag("DRAMSim2")
diff -r 62ea1e981b06 src/mem/nvmain_mem.cc
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/mem/nvmain_mem.cc	Fri Jun 13 18:21:07 2014 -0400
@@ -0,0 +1,780 @@
+/*
+ * Copyright (c) 2012-2014 Pennsylvania State University
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met: redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer;
+ * redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution;
+ * neither the name of the copyright holders nor the names of its
+ * contributors may be used to endorse or promote products derived from
+ * this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/*
+ *  This file is part of NVMain- A cycle accurate timing, bit-accurate
+ *  energy simulator for non-volatile memory. Originally developed by
+ *  Matt Poremba at the Pennsylvania State University.
+ *
+ *  Website: http://www.cse.psu.edu/~poremba/nvmain/
+ *  Email: mrp5060@psu.edu
+ *
+ *  ---------------------------------------------------------------------
+ *
+ *  If you use this software for publishable research, please include
+ *  the original NVMain paper in the citation list and mention the use
+ *  of NVMain.
+ *
+ */
+
+#include "SimInterface/Gem5Interface/Gem5Interface.h"
+#include "Utils/HookFactory.h"
+#include "base/random.hh"
+#include "base/statistics.hh"
+#include "debug/NVMain.hh"
+#include "debug/NVMainMin.hh"
+#include "mem/nvmain_mem.hh"
+
+using namespace NVM;
+
+NVMainMemory *NVMainMemory::masterInstance = NULL;
+
+NVMainMemory::NVMainMemory(const Params *p)
+    : AbstractMemory(p), clockEvent(this), drainManager(NULL), lat(p->atomic_latency),
+      lat_var(p->atomic_variance), nvmain_atomic(p->atomic_mode),
+      NVMainWarmUp(p->NVMainWarmUp), port(name() + ".port", *this)
+{
+    char *cfgparams;
+    char *cfgvalues;
+    char *cparam, *cvalue;
+
+    char *saveptr1, *saveptr2;
+
+    m_nvmainPtr = NULL;
+    m_nacked_requests = false;
+
+    m_nvmainConfigPath = p->config;
+
+    m_nvmainConfig = new Config( );
+
+    m_nvmainConfig->Read( m_nvmainConfigPath );
+    std::cout << "NVMainControl: Reading NVMain config file: " << m_nvmainConfigPath << "." << std::endl;
+
+    clock = clockPeriod( );
+
+    m_awake = false;
+
+    m_avgAtomicLatency = 100.0f;
+    m_numAtomicAccesses = 0;
+
+    retryRead = false;
+    retryWrite = false;
+    retryResp = false;
+    m_requests_outstanding = 0;
+
+    /*
+     * Modified by Tao @ 01/22/2013
+     * multiple parameters can be manually specified
+     * please separate the parameters by comma ","
+     * For example,
+     *    configparams = tRCD,tCAS,tRP
+     *    configvalues = 8,8,8
+     */
+    cfgparams = (char *)p->configparams.c_str();
+    cfgvalues = (char *)p->configvalues.c_str();
+
+    for( cparam = strtok_r( cfgparams, ",", &saveptr1 ), cvalue = strtok_r( cfgvalues, ",", &saveptr2 )
+           ; (cparam && cvalue) ; cparam = strtok_r( NULL, ",", &saveptr1 ), cvalue = strtok_r( NULL, ",", &saveptr2) )
+    {
+        std::cout << "NVMain: Overriding parameter `" << cparam << "' with `" << cvalue << "'" << std::endl;
+        m_nvmainConfig->SetValue( cparam, cvalue );
+    }
+
+   BusWidth = m_nvmainConfig->GetValue( "BusWidth" );
+   tBURST = m_nvmainConfig->GetValue( "tBURST" );
+   RATE = m_nvmainConfig->GetValue( "RATE" );
+
+   lastWakeup = curTick();
+}
+
+
+NVMainMemory::~NVMainMemory()
+{
+    std::cout << "NVMain dtor called" << std::endl;
+}
+
+
+void
+NVMainMemory::init()
+{
+    if (!port.isConnected()) {
+        fatal("NVMainMemory %s is unconnected!\n", name());
+    } else {
+        port.sendRangeChange();
+    }
+
+    if( masterInstance == NULL )
+    {
+        masterInstance = this;
+
+        m_nvmainPtr = new NVM::NVMain( );
+        m_statsPtr = new NVM::Stats( );
+        m_nvmainSimInterface = new NVM::Gem5Interface( );
+        m_nvmainEventQueue = new NVM::EventQueue( );
+        m_nvmainGlobalEventQueue = new NVM::GlobalEventQueue( );
+        m_tagGenerator = new NVM::TagGenerator( 1000 );
+
+        m_nvmainConfig->SetSimInterface( m_nvmainSimInterface );
+
+        statPrinter.nvmainPtr = m_nvmainPtr;
+        statReseter.nvmainPtr = m_nvmainPtr;
+
+        if( m_nvmainConfig->KeyExists( "StatsFile" ) )
+        {
+            statPrinter.statStream.open( m_nvmainConfig->GetString( "StatsFile" ).c_str(),
+                                         std::ofstream::out | std::ofstream::app );
+        }
+
+        //registerExitCallback( &statPrinter );
+        ::Stats::registerDumpCallback( &statPrinter );
+        ::Stats::registerResetCallback( &statReseter );
+
+        SetEventQueue( m_nvmainEventQueue );
+        SetStats( m_statsPtr );
+        SetTagGenerator( m_tagGenerator );
+
+        m_nvmainGlobalEventQueue->SetFrequency( m_nvmainConfig->GetEnergy( "CLK" ) * 1000000.0 );
+        SetGlobalEventQueue( m_nvmainGlobalEventQueue );
+
+        // TODO: Confirm global event queue frequency is the same as this SimObject's clock.
+
+        /*  Add any specified hooks */
+        std::vector<std::string>& hookList = m_nvmainConfig->GetHooks( );
+
+        for( size_t i = 0; i < hookList.size( ); i++ )
+        {
+            std::cout << "Creating hook " << hookList[i] << std::endl;
+
+            NVMObject *hook = HookFactory::CreateHook( hookList[i] );
+
+            if( hook != NULL )
+            {
+                AddHook( hook );
+                hook->SetParent( this );
+                hook->Init( m_nvmainConfig );
+            }
+            else
+            {
+                std::cout << "Warning: Could not create a hook named `"
+                    << hookList[i] << "'." << std::endl;
+            }
+        }
+
+        /* Setup child and parent modules. */
+        AddChild( m_nvmainPtr );
+        m_nvmainPtr->SetParent( this );
+        m_nvmainGlobalEventQueue->AddSystem( m_nvmainPtr, m_nvmainConfig );
+        m_nvmainPtr->SetConfig( m_nvmainConfig );
+    }
+}
+
+
+void NVMainMemory::startup()
+{
+    DPRINTF(NVMain, "NVMainMemory: startup() called.\n");
+    DPRINTF(NVMainMin, "NVMainMemory: startup() called.\n");
+
+    /*
+     *  Schedule the initial event. Needed for warmup and timing mode.
+     *  If we are in atomic/fast-forward, wakeup will be disabled upon
+     *  the first atomic request receieved in recvAtomic().
+     */
+    schedule(clockEvent, curTick() + clock);
+    m_awake = true;
+}
+
+
+void NVMainMemory::wakeup()
+{
+    DPRINTF(NVMain, "NVMainMemory: wakeup() called.\n");
+    DPRINTF(NVMainMin, "NVMainMemory: wakeup() called.\n");
+    schedule(clockEvent, clockEdge());
+}
+
+
+BaseSlavePort &
+NVMainMemory::getSlavePort(const std::string& if_name, PortID idx)
+{
+    if (if_name != "port") {
+        return MemObject::getSlavePort(if_name, idx);
+    } else {
+        return port;
+    }
+}
+
+
+void NVMainMemory::NVMainStatPrinter::process()
+{
+    assert(nvmainPtr != NULL);
+
+    nvmainPtr->CalculateStats();
+    std::ostream& refStream = (statStream.is_open()) ? statStream : std::cout;
+    nvmainPtr->GetStats()->PrintAll( refStream );
+}
+
+
+void NVMainMemory::NVMainStatReseter::process()
+{
+    assert(nvmainPtr != NULL);
+
+    nvmainPtr->GetStats()->ResetAll( );
+}
+
+
+NVMainMemory::MemoryPort::MemoryPort(const std::string& _name, NVMainMemory& _memory)
+    : SlavePort(_name, &_memory), memory(_memory)
+{
+
+}
+
+
+AddrRangeList NVMainMemory::MemoryPort::getAddrRanges() const
+{
+    AddrRangeList ranges;
+    ranges.push_back(memory.getAddrRange());
+    return ranges;
+}
+
+
+Tick
+NVMainMemory::MemoryPort::recvAtomic(PacketPtr pkt)
+{
+    if (pkt->memInhibitAsserted())
+        return 0;
+
+    /*
+     * do the memory access to get the read data and change the response tag
+     */
+    memory.access(pkt);
+
+    /*
+     * calculate the latency. Now it is only random number
+     */
+    Tick latency = memory.lat;
+
+    if (memory.lat_var != 0)
+        latency += random_mt.random<Tick>(0, memory.lat_var);
+
+    /*
+     *  if NVMain also needs the packet to warm up the inline cache, create the request
+     */
+    if( memory.NVMainWarmUp )
+    {
+        NVMainRequest *request = new NVMainRequest( );
+        unsigned int transfer_size;
+        uint8_t *hostAddr;
+
+        transfer_size =  memory.BusWidth / 8;
+        transfer_size *= memory.tBURST * memory.RATE;
+
+        /* extract the data in the packet */
+        if( pkt->isRead() )
+        {   // read
+            hostAddr = new uint8_t[ pkt->getSize() ];
+            memcpy( hostAddr, pkt->getPtr<uint8_t>(), pkt->getSize() );
+        }
+        else if( pkt->isWrite() )
+        {   // write
+            hostAddr = new uint8_t[ pkt->getSize() ];
+            memcpy( hostAddr, pkt->getPtr<uint8_t>(), pkt->getSize() );
+        }
+        else
+        {
+            // if it is neither read nor write, just return
+            // well, speed may suffer a little bit...
+            return latency;
+        }
+
+        /* store the data into the request */
+        for(int i = 0; i < transfer_size; i++ )
+        {
+            request->data.SetByte(i, *(hostAddr + (transfer_size - 1) - i));
+        }
+        delete [] hostAddr;
+
+        /* initialize the request so that NVMain can correctly serve it */
+        request->access = UNKNOWN_ACCESS;
+        request->address.SetPhysicalAddress(pkt->req->getPaddr());
+        request->status = MEM_REQUEST_INCOMPLETE;
+        request->type = (pkt->isRead()) ? READ : WRITE;
+        request->owner = (NVMObject *)&memory;
+        if(pkt->req->hasPC()) request->programCounter = pkt->req->getPC();
+        if(pkt->req->hasContextId()) request->threadId = pkt->req->contextId();
+
+        /*
+         * Issue the request to NVMain as an atomic request
+         */
+        memory.m_nvmainPtr->IssueAtomic(request);
+
+        delete request;
+    }
+    else
+    {
+        // If we switch back to atomic mode, disable the gem5 event
+        if( memory.m_awake )
+        {
+            memory.m_awake = false;
+        }
+    }
+
+    return latency;
+}
+
+
+void
+NVMainMemory::MemoryPort::recvFunctional(PacketPtr pkt)
+{
+    pkt->pushLabel(memory.name());
+
+    memory.doFunctionalAccess(pkt);
+
+    for( std::deque<PacketPtr>::iterator i = memory.responseQueue.begin();
+         i != memory.responseQueue.end(); ++i )
+        pkt->checkFunctional(*i);
+
+    pkt->popLabel();
+}
+
+
+bool
+NVMainMemory::MemoryPort::recvTimingReq(PacketPtr pkt)
+{
+    /* added by Tao @ 01/24/2013, just copy the code from SimpleMemory */
+    /// @todo temporary hack to deal with memory corruption issues until
+    /// 4-phase transactions are complete
+    for (int x = 0; x < memory.pendingDelete.size(); x++)
+        delete memory.pendingDelete[x];
+    memory.pendingDelete.clear();
+
+    if (pkt->memInhibitAsserted()) {
+        memory.pendingDelete.push_back(pkt);
+        return true;
+    }
+
+
+    if (!pkt->isRead() && !pkt->isWrite()) {
+        DPRINTF(NVMain, "NVMainMemory: Received a packet that is neither read nor write.\n");
+        DPRINTF(NVMainMin, "NVMainMemory: Received a packet that is neither read nor write.\n");
+
+        bool needsResponse = pkt->needsResponse();
+
+        memory.access(pkt);
+        if (needsResponse) {
+            assert(pkt->isResponse());
+
+            pkt->busFirstWordDelay = pkt->busLastWordDelay = 0;
+            memory.responseQueue.push_back(pkt);
+        } else {
+            memory.pendingDelete.push_back(pkt);
+        }
+
+        return true;
+    }
+
+
+    if (memory.retryRead || memory.retryWrite)
+    {
+        DPRINTF(NVMain, "nvmain_mem.cc: Received request while waiting for retry!\n");
+        DPRINTF(NVMainMin, "nvmain_mem.cc: Received request while waiting for retry!\n");
+        return false;
+    }
+
+    // Make sure we are awake if we are in timing mode
+    if( !memory.m_awake )
+    {
+        memory.m_awake = true;
+        memory.wakeup();
+    }
+
+    // Bus latency is modeled in NVMain.
+    pkt->busFirstWordDelay = pkt->busLastWordDelay = 0;
+
+    NVMainRequest *request = new NVMainRequest( );
+
+    bool canQueue, enqueued = false;
+    unsigned int transfer_size;
+    uint8_t *hostAddr;
+
+    transfer_size =  memory.BusWidth / 8;
+    transfer_size *= memory.tBURST * memory.RATE;
+
+    if (pkt->isRead())
+    {
+        Request *dataReq = new Request(pkt->req->getPaddr(), transfer_size, 0, Request::funcMasterId);
+        Packet *dataPkt = new Packet(dataReq, MemCmd::ReadReq);
+        dataPkt->allocate();
+        memory.doFunctionalAccess(dataPkt);
+
+        hostAddr = new uint8_t[ dataPkt->getSize() ];
+        memcpy( hostAddr, dataPkt->getPtr<uint8_t>(), dataPkt->getSize() );
+
+        delete dataPkt;
+        delete dataReq;
+    }
+    else
+    {
+        hostAddr = new uint8_t[ pkt->getSize() ];
+
+        memcpy( hostAddr, pkt->getPtr<uint8_t>(), pkt->getSize() );
+    }
+
+    for(int i = 0; i < transfer_size; i++ )
+    {
+        request->data.SetByte(i, *(hostAddr + (transfer_size - 1) - i));
+    }
+    delete [] hostAddr;
+
+    request->access = UNKNOWN_ACCESS;
+    request->address.SetPhysicalAddress(pkt->req->getPaddr());
+    request->status = MEM_REQUEST_INCOMPLETE;
+    request->type = (pkt->isRead()) ? READ : WRITE;
+    request->owner = (NVMObject *)&memory;
+
+    if(pkt->req->hasPC()) request->programCounter = pkt->req->getPC();
+    if(pkt->req->hasContextId()) request->threadId = pkt->req->contextId();
+
+    /* Call hooks here manually, since there is no one else to do it. */
+    std::vector<NVMObject *>& preHooks  = memory.masterInstance->GetHooks( NVMHOOK_PREISSUE );
+    std::vector<NVMObject *>& postHooks = memory.masterInstance->GetHooks( NVMHOOK_POSTISSUE );
+    std::vector<NVMObject *>::iterator it;
+
+    canQueue = memory.masterInstance->GetChild( )->IsIssuable( request );
+
+    if( canQueue )
+    {
+        /* Call pre-issue hooks */
+        for( it = preHooks.begin(); it != preHooks.end(); it++ )
+        {
+            (*it)->SetParent( memory.masterInstance );
+            (*it)->IssueCommand( request );
+        }
+
+        enqueued = memory.masterInstance->GetChild( )->IssueCommand(request);
+        assert( enqueued == true );
+
+        NVMainMemoryRequest *memRequest = new NVMainMemoryRequest;
+
+        memRequest->request = request;
+        memRequest->packet = pkt;
+        memRequest->issueTick = curTick();
+        memRequest->atomic = false;
+
+        DPRINTF(NVMain, "nvmain_mem.cc: Enqueued Mem request for 0x%x of type %s\n", request->address.GetPhysicalAddress( ), ((pkt->isRead()) ? "READ" : "WRITE") );
+
+        memory.masterInstance->m_request_map.insert( std::pair<NVMainRequest *, NVMainMemoryRequest *>( request, memRequest ) );
+        memory.m_requests_outstanding++;
+
+        /*
+         *  It seems gem5 will block until the packet gets a response, so create a copy of the request, so
+         *  the memory controller has it, then delete the original copy to respond to the packet.
+         */
+        if( request->type == WRITE )
+        {
+            NVMainMemoryRequest *requestCopy = new NVMainMemoryRequest( );
+
+            requestCopy->request = new NVMainRequest( );
+            *(requestCopy->request) = *request;
+            requestCopy->packet = pkt;
+            requestCopy->issueTick = curTick();
+            requestCopy->atomic = false;
+
+            memRequest->packet = NULL;
+
+            memory.masterInstance->m_request_map.insert( std::pair<NVMainRequest *, NVMainMemoryRequest *>( requestCopy->request, requestCopy ) );
+            memory.m_requests_outstanding++;
+
+            memory.RequestComplete( requestCopy->request );
+        }
+
+        /* Call post-issue hooks. */
+        if( request != NULL )
+        {
+            for( it = postHooks.begin(); it != postHooks.end(); it++ )
+            {
+                (*it)->SetParent( &memory );
+                (*it)->IssueCommand( request );
+            }
+        }
+    }
+    else
+    {
+        DPRINTF(NVMain, "nvmain_mem.cc: Can not enqueue Mem request for 0x%x of type %s\n", request->address.GetPhysicalAddress( ), ((pkt->isRead()) ? "READ" : "WRITE") );
+        DPRINTF(NVMainMin, "nvmain_mem.cc: Can not enqueue Mem request for 0x%x of type %s\n", request->address.GetPhysicalAddress( ), ((pkt->isRead()) ? "READ" : "WRITE") );
+
+        if (pkt->isRead())
+        {
+            memory.retryRead = true;
+        }
+        else
+        {
+            memory.retryWrite = true;
+        }
+
+        delete request;
+        request = NULL;
+    }
+
+    return enqueued;
+}
+
+
+
+Tick NVMainMemory::doAtomicAccess(PacketPtr pkt)
+{
+    access(pkt);
+    return static_cast<Tick>(m_avgAtomicLatency);
+}
+
+
+
+void NVMainMemory::doFunctionalAccess(PacketPtr pkt)
+{
+    functionalAccess(pkt);
+}
+
+
+unsigned int NVMainMemory::drain(DrainManager *dm)
+{
+    unsigned int rv= 0;
+
+    if( !masterInstance->m_request_map.empty() )
+    {
+        setDrainState(Drainable::Draining);
+        drainManager = dm;
+        rv = 1;
+    }
+    else
+    {
+        setDrainState(Drainable::Drained);
+        rv = 0;
+    }
+
+    return rv;
+}
+
+
+void NVMainMemory::MemoryPort::recvRetry( )
+{
+    memory.recvRetry( );
+}
+
+
+void NVMainMemory::recvRetry( )
+{
+    DPRINTF(NVMain, "NVMainMemory: recvRetry() called.\n");
+    DPRINTF(NVMainMin, "NVMainMemory: recvRetry() called.\n");
+
+    retryResp = false;
+    SendResponses( );
+}
+
+
+bool NVMainMemory::RequestComplete(NVM::NVMainRequest *req)
+{
+    bool isRead = (req->type == READ || req->type == READ_PRECHARGE);
+    bool isWrite = (req->type == WRITE || req->type == WRITE_PRECHARGE);
+
+    /* Ignore bus read/write requests generated by the banks. */
+    if( req->type == BUS_WRITE || req->type == BUS_READ )
+    {
+        delete req;
+        return true;
+    }
+
+    NVMainMemoryRequest *memRequest;
+    std::map<NVMainRequest *, NVMainMemoryRequest *>::iterator iter;
+
+    // Find the mem request pointer in the map.
+    assert(masterInstance->m_request_map.count(req) != 0);
+    iter = masterInstance->m_request_map.find(req);
+    memRequest = iter->second;
+
+    if(!memRequest->atomic)
+    {
+        bool respond = false;
+
+        if( memRequest->packet )
+        {
+            respond = memRequest->packet->needsResponse();
+            access(memRequest->packet);
+        }
+
+        /*
+         *  If we have combined queues (FRFCFS/FCFS) there is a problem.
+         *  I assume that gem5 will stall such that only one type of request
+         *  will need a retry, however I do not explicitly enfore that only
+         *  one sendRetry() be called.
+         */
+        NVMainMemory *ownerInstance = dynamic_cast<NVMainMemory *>( req->owner );
+        assert( ownerInstance != NULL );
+
+        if( ownerInstance->retryRead == true && (isRead || isWrite) )
+        {
+            ownerInstance->retryRead = false;
+            ownerInstance->port.sendRetry();
+        }
+        if( ownerInstance->retryWrite == true && (isRead || isWrite) )
+        {
+            ownerInstance->retryWrite = false;
+            ownerInstance->port.sendRetry();
+        }
+
+        DPRINTF(NVMain, "Completed Mem request for 0x%x of type %s\n", req->address.GetPhysicalAddress( ), (isRead ? "READ" : "WRITE"));
+
+        if(respond)
+        {
+            ownerInstance->responseQueue.push_back(memRequest->packet);
+
+            delete req;
+            delete memRequest;
+        }
+        else
+        {
+            if( memRequest->packet )
+                ownerInstance->pendingDelete.push_back(memRequest->packet);
+
+            CheckDrainState( );
+
+            delete req;
+            delete memRequest;
+        }
+    }
+    else
+    {
+        delete req;
+        delete memRequest;
+    }
+
+
+    masterInstance->m_request_map.erase(iter);
+    m_requests_outstanding--;
+
+    return true;
+}
+
+
+void NVMainMemory::SendResponses( )
+{
+    if( responseQueue.empty() || retryResp == true )
+        return;
+
+
+    bool success = port.sendTimingResp( responseQueue.front() );
+
+    if( success )
+    {
+        DPRINTF(NVMain, "NVMainMemory: Sending response.\n");
+
+        responseQueue.pop_front( );
+
+        CheckDrainState( );
+    }
+    else
+    {
+        DPRINTF(NVMain, "NVMainMemory: Retrying response.\n");
+        DPRINTF(NVMainMin, "NVMainMemory: Retrying response.\n");
+
+        retryResp = true;
+    }
+}
+
+
+void NVMainMemory::CheckDrainState( )
+{
+    if( drainManager != NULL && masterInstance->m_request_map.empty() )
+    {
+        DPRINTF(NVMain, "NVMainMemory: Drain completed.\n");
+        DPRINTF(NVMainMin, "NVMainMemory: Drain completed.\n");
+
+        drainManager->signalDrainDone( );
+        drainManager = NULL;
+    }
+}
+
+
+void NVMainMemory::serialize(std::ostream& os)
+{
+    if (masterInstance != this)
+        return;
+
+    std::string nvmain_chkpt_dir = "";
+
+    if( m_nvmainConfig->KeyExists( "CheckpointDirectory" ) )
+        nvmain_chkpt_dir = m_nvmainConfig->GetString( "CheckpointDirectory" );
+
+    if( nvmain_chkpt_dir != "" )
+    {
+        std::cout << "NVMainMemory: Writing to checkpoint directory " << nvmain_chkpt_dir << std::endl;
+
+        m_nvmainPtr->CreateCheckpoint( nvmain_chkpt_dir );
+    }
+}
+
+
+void NVMainMemory::unserialize(Checkpoint *cp, const std::string& section)
+{
+    if (masterInstance != this)
+        return;
+
+    std::string nvmain_chkpt_dir = "";
+
+    if( m_nvmainConfig->KeyExists( "CheckpointDirectory" ) )
+        nvmain_chkpt_dir = m_nvmainConfig->GetString( "CheckpointDirectory" );
+
+    if( nvmain_chkpt_dir != "" )
+    {
+        std::cout << "NVMainMemory: Reading from checkpoint directory " << nvmain_chkpt_dir << std::endl;
+
+        m_nvmainPtr->RestoreCheckpoint( nvmain_chkpt_dir );
+    }
+}
+
+
+void NVMainMemory::tick( )
+{
+    // Cycle memory controller
+    if (masterInstance == this)
+        m_nvmainPtr->Cycle( 1 );
+
+    if( retryResp == false )
+        SendResponses( );
+
+    // Don't schedule event in atomic mode unless there are incomplete requests
+    if( m_awake || !masterInstance->m_request_map.empty() )
+    {
+        schedule(clockEvent, curTick() + clock);
+    }
+}
+
+
+NVMainMemory *
+NVMainMemoryParams::create()
+{
+    return new NVMainMemory(this);
+}
+
diff -r 62ea1e981b06 src/mem/nvmain_mem.hh
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/mem/nvmain_mem.hh	Fri Jun 13 18:21:07 2014 -0400
@@ -0,0 +1,204 @@
+/*
+ * Copyright (c) 2012-2013 Pennsylvania State University
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met: redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer;
+ * redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution;
+ * neither the name of the copyright holders nor the names of its
+ * contributors may be used to endorse or promote products derived from
+ * this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/*
+ *  This file is part of NVMain- A cycle accurate timing, bit-accurate
+ *  energy simulator for non-volatile memory. Originally developed by
+ *  Matt Poremba at the Pennsylvania State University.
+ *
+ *  Website: http://www.cse.psu.edu/~poremba/nvmain/
+ *  Email: mrp5060@psu.edu
+ *
+ *  ---------------------------------------------------------------------
+ *
+ *  If you use this software for publishable research, please include
+ *  the original NVMain paper in the citation list and mention the use
+ *  of NVMain.
+ *
+ */
+
+#ifndef __MEM_NVMAIN_MEM_HH__
+#define __MEM_NVMAIN_MEM_HH__
+
+
+#include <fstream>
+#include <ostream>
+
+#include "NVM/nvmain.h"
+#include "base/callback.hh"
+#include "include/NVMTypes.h"
+#include "include/NVMainRequest.h"
+#include "mem/abstract_mem.hh"
+#include "mem/tport.hh"
+#include "params/NVMainMemory.hh"
+#include "sim/eventq.hh"
+#include "sim/serialize.hh"
+#include "src/Config.h"
+#include "src/EventQueue.h"
+#include "src/NVMObject.h"
+#include "src/SimInterface.h"
+#include "src/TagGenerator.h"
+
+class NVMainMemory : public AbstractMemory, public NVM::NVMObject
+{
+  private:
+
+    class MemoryPort : public SlavePort
+    {
+        friend class NVMainMemory;
+
+//        SlavePacketQueue queueImpl;
+        NVMainMemory& memory;
+
+      public:
+
+        MemoryPort(const std::string& _name, NVMainMemory& _memory);
+
+      protected:
+
+        Tick recvAtomic(PacketPtr pkt);
+
+        void recvFunctional(PacketPtr pkt);
+
+        bool recvTimingReq(PacketPtr pkt);
+
+        void recvRetry( );
+
+        AddrRangeList getAddrRanges() const;
+
+    };
+
+    void tick();
+    EventWrapper<NVMainMemory, &NVMainMemory::tick> clockEvent;
+
+    void SendResponses( );
+    void CheckDrainState( );
+
+    class NVMainStatPrinter : public Callback
+    {
+      public:
+        void process();
+
+        NVM::NVMain *nvmainPtr;
+        std::ofstream statStream;
+    };
+
+    class NVMainStatReseter : public Callback
+    {
+      public:
+        void process();
+
+        NVM::NVMain *nvmainPtr;
+    };
+
+    struct NVMainMemoryRequest
+    {
+        PacketPtr packet;
+        NVM::NVMainRequest *request;
+        Tick issueTick;
+        bool atomic;
+    };
+
+    DrainManager *drainManager;
+
+    NVM::NVMain *m_nvmainPtr;
+    NVM::Stats *m_statsPtr;
+    NVM::EventQueue *m_nvmainEventQueue;
+    NVM::GlobalEventQueue *m_nvmainGlobalEventQueue;
+    NVM::Config *m_nvmainConfig;
+    NVM::SimInterface *m_nvmainSimInterface;
+    NVM::TagGenerator *m_tagGenerator;
+    std::string m_nvmainConfigPath;
+
+    bool m_awake;
+    bool m_nacked_requests;
+    float m_avgAtomicLatency;
+    uint64_t m_numAtomicAccesses;
+
+    Tick clock;
+    Tick lat;
+    Tick lat_var;
+    bool nvmain_atomic;
+
+    uint64_t BusWidth;
+    uint64_t tBURST;
+    uint64_t RATE;
+
+    bool NVMainWarmUp;
+
+    NVMainStatPrinter statPrinter;
+    NVMainStatReseter statReseter;
+    Tick lastWakeup;
+
+    uint64_t m_requests_outstanding;
+
+  public:
+
+    typedef NVMainMemoryParams Params;
+    NVMainMemory(const Params *p);
+    virtual ~NVMainMemory();
+
+    BaseSlavePort& getSlavePort(const std::string& if_name,
+                                PortID idx = InvalidPortID);
+    void init();
+    void startup();
+    void wakeup();
+
+    const Params *
+    params() const
+    {
+        return dynamic_cast<const Params *>(_params);
+    }
+
+
+    bool RequestComplete( NVM::NVMainRequest *req );
+
+    void Cycle(NVM::ncycle_t) { }
+
+    unsigned int drain(DrainManager *dm);
+
+    void serialize(std::ostream& os);
+    void unserialize(Checkpoint *cp, const std::string& section);
+
+    MemoryPort port;
+    static NVMainMemory *masterInstance;
+    bool retryRead, retryWrite, retryResp;
+    std::deque<PacketPtr> responseQueue;
+    std::vector<PacketPtr> pendingDelete;
+    std::map<NVM::NVMainRequest *, NVMainMemoryRequest *> m_request_map;
+
+  protected:
+
+    Tick doAtomicAccess(PacketPtr pkt);
+    void doFunctionalAccess(PacketPtr pkt);
+    void recvRetry();
+
+};
+
+#endif
+
