diff -r 1490f4f0b9a4 configs/nvmain/nvm_classic.py
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/configs/nvmain/nvm_classic.py	Mon Jan 07 14:25:11 2013 -0500
@@ -0,0 +1,191 @@
+# Copyright (c) 2006-2008 The Regents of The University of Michigan
+# All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions are
+# met: redistributions of source code must retain the above copyright
+# notice, this list of conditions and the following disclaimer;
+# redistributions in binary form must reproduce the above copyright
+# notice, this list of conditions and the following disclaimer in the
+# documentation and/or other materials provided with the distribution;
+# neither the name of the copyright holders nor the names of its
+# contributors may be used to endorse or promote products derived from
+# this software without specific prior written permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+#
+# Author: Matt Poremba
+
+
+import os
+import optparse
+import sys
+from os.path import join as joinpath
+
+import m5
+from m5.defines import buildEnv
+from m5.objects import *
+from m5.util import addToPath, fatal
+
+if buildEnv['FULL_SYSTEM']:
+    fatal("This script requires syscall emulation mode (*_SE).")
+
+addToPath('../common')
+addToPath('../topologies')
+addToPath('../ruby')
+
+import Options
+import Ruby
+import Simulation
+import CacheConfig
+from Caches import *
+from cpu2000 import *
+
+
+
+# Get paths we might need.  It's expected this file is in m5/configs/example.
+config_path = os.path.dirname(os.path.abspath(__file__))
+config_root = os.path.dirname(config_path)
+m5_root = os.path.dirname(config_root)
+
+parser = optparse.OptionParser()
+Options.addCommonOptions(parser)
+Options.addSEOptions(parser)
+
+if '--ruby' in sys.argv:
+    Ruby.define_options(parser)
+
+# Benchmark options
+parser.add_option("--stdout", action="store_true", help="Print benchmark output to stdout instead of a file.")
+parser.add_option("--nvmain_PARAM", type="string", default="NULL", help="Set NVMain configuration value for PARAM (e.g., --nvmain_RANKS 4, --nvmain_BANKS 8, etc.)");
+
+# Memory Size Options
+parser.add_option("--mem-size", action="store", type="string", default="512MB",
+                  help="Specify the physical memory size (single memory)")
+
+
+#
+#  Check for extra nvmain configuration override options and add them as options to python
+#
+argnum = 1
+for arg in sys.argv:
+    if arg[:9] == "--nvmain_":
+        parser.add_option(arg, type="string", default="NULL", help="Set NVMain configuration value for PARAM")
+    argnum = argnum + 1
+
+execfile(os.path.join(config_root, "common", "Options.py"))
+
+
+#
+#  Parse arguments
+#
+(options, args) = parser.parse_args()
+
+
+numThreads = 1
+
+
+#
+#  Setup CPU classic and memory access mode based on options
+#
+(CPUClass, test_mem_mode, FutureClass) = Simulation.setCPUClass(options)
+CPUClass.clock = '2GHz'
+CPUClass.numThreads = numThreads;
+
+np = options.num_cpus
+print "Creating %d CPUs" % np
+print "Test mem mode is %s" % test_mem_mode
+
+#
+#  Create the system
+#
+system = System(cpu = [CPUClass(cpu_id=i) for i in xrange(np)],
+                membus = CoherentBus(), mem_mode = test_mem_mode)
+
+
+#
+#  Use SimpleMemory with ruby (protocol overrides to NVMainControl) and NVMainMemory for classic caches
+#
+if '--ruby' in sys.argv:
+    system.physmem = SimpleMemory(range=AddrRange(options.mem_size))
+else:
+    system.physmem = NVMainMemory(range=AddrRange(options.mem_size))
+
+options.use_map = True
+
+if options.ruby:
+    Ruby.create_system(options, system)
+    assert(options.num_cpus == len(system.ruby._cpu_ruby_ports))
+
+
+#
+#  Create the configuration overrides string for NVMain
+#
+nvmaincfg = ""
+nvmaincfgparams = ""
+nvmaincfgvalues = ""
+
+argnum = 1
+for arg in sys.argv:
+    if arg[:9] == "--nvmain_":
+        if nvmaincfgparams != "":
+            nvmaincfgparams += ","
+            nvmaincfgvalues += ","
+        nvmaincfgparams += arg[9:]
+        nvmaincfgvalues += sys.argv[argnum]
+
+        if arg == '--nvmain_config':
+            nvmaincfg = sys.argv[argnum]
+    argnum = argnum + 1
+
+
+#
+#  Pass the configuration overrides to NVMainControl or NVMainMemory depending on ruby/classic mode
+#
+if options.ruby:
+    for i in xrange(options.num_dirs):
+        exec("system.dir_cntrl%d.memBuffer.configparams = nvmaincfgparams" % i)
+        exec("system.dir_cntrl%d.memBuffer.configvalues = nvmaincfgvalues" % i)
+else:
+    system.physmem.config = nvmaincfg
+    system.physmem.configparams = nvmaincfgparams
+    system.physmem.configvalues = nvmaincfgvalues
+    system.physmem.cpu_frequency = CPUClass.clock
+
+
+
+#
+#  Assign comma delimited programs to each CPU
+#
+for i in xrange(np):
+    process = LiveProcess()
+    process.executable = options.cmd
+    process.cmd = [options.cmd] + options.options.split()
+
+    system.cpu[i].workload = process
+    print "CPU %d is running process %s" % (i, process.cmd)
+
+    system.cpu[i].createInterruptController()
+
+    if options.ruby:
+        system.cpu[i].icache_port = system.ruby._cpu_ruby_ports[i].slave
+        system.cpu[i].dcache_port = system.ruby._cpu_ruby_ports[i].slave
+
+if not options.ruby:
+    system.system_port = system.membus.slave
+    system.physmem.port = system.membus.master
+    CacheConfig.config_cache(options, system)
+
+
+root = Root(full_system = False, system = system)
+Simulation.run(options, root, system, FutureClass)
