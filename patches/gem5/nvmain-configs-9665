diff -r 0a99ff93b4fc configs/example/fs.py
--- a/configs/example/fs.py	Tue Jun 25 12:56:57 2013 -0400
+++ b/configs/example/fs.py	Tue Jun 25 13:13:40 2013 -0400
@@ -89,6 +89,8 @@
 DriveMemClass = SimpleMemory
 TestMemClass = Simulation.setMemClass(options)
 
+print options.mem_size
+
 if options.benchmark:
     try:
         bm = Benchmarks[options.benchmark]
@@ -102,6 +104,8 @@
     else:
         bm = [SysConfig(disk=options.disk_image, mem=options.mem_size)]
 
+print options.mem_size
+
 np = options.num_cpus
 
 if buildEnv['TARGET_ISA'] == "alpha":
diff -r 0a99ff93b4fc configs/nvmain/fs.py
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/configs/nvmain/fs.py	Tue Jun 25 13:13:40 2013 -0400
@@ -0,0 +1,206 @@
+# Copyright (c) 2010-2012 ARM Limited
+# All rights reserved.
+#
+# The license below extends only to copyright in the software and shall
+# not be construed as granting a license to any other intellectual
+# property including but not limited to intellectual property relating
+# to a hardware implementation of the functionality of the software
+# licensed hereunder.  You may use the software subject to the license
+# terms below provided that you ensure that this notice is replicated
+# unmodified and in its entirety in all distributions of the software,
+# modified or unmodified, in source code or in binary form.
+#
+# Copyright (c) 2006-2007 The Regents of The University of Michigan
+# All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions are
+# met: redistributions of source code must retain the above copyright
+# notice, this list of conditions and the following disclaimer;
+# redistributions in binary form must reproduce the above copyright
+# notice, this list of conditions and the following disclaimer in the
+# documentation and/or other materials provided with the distribution;
+# neither the name of the copyright holders nor the names of its
+# contributors may be used to endorse or promote products derived from
+# this software without specific prior written permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+#
+# Authors: Ali Saidi
+
+import optparse
+import sys
+
+import m5
+from m5.defines import buildEnv
+from m5.objects import *
+from m5.util import addToPath, fatal
+
+addToPath('../common')
+
+from FSConfig import *
+from SysPaths import *
+from Benchmarks import *
+import Simulation
+import CacheConfig
+from Caches import *
+import Options
+
+parser = optparse.OptionParser()
+Options.addCommonOptions(parser)
+Options.addFSOptions(parser)
+
+parser.add_option("--nvmain-config", type="string", default="NULL", help="Set NVMain configuration file")
+parser.add_option("--no-nvmain", action="store_true", help="Don't use nvmain, use simple memory.")
+parser.add_option("--nvmain_warmup", action="store_true", help="Enable warm up of internal caches in NVMain (i.e., DRAMCaches, etc)")
+
+(options, args) = parser.parse_args()
+
+if args:
+    print "Error: script doesn't take any positional arguments"
+    sys.exit(1)
+
+# driver system CPU is always simple... note this is an assignment of
+# a class, not an instance.
+DriveCPUClass = AtomicSimpleCPU
+drive_mem_mode = 'atomic'
+
+# system under test can be any CPU
+(TestCPUClass, test_mem_mode, FutureClass) = Simulation.setCPUClass(options)
+
+TestCPUClass.clock = options.clock
+DriveCPUClass.clock = options.clock
+
+TestMemClass = NVMainMemory()
+
+useNVMain = True
+if options.no_nvmain:
+    TestMemClass = Simulation.setMemClass(options)
+    useNVMain = False
+
+
+if options.benchmark:
+    try:
+        bm = Benchmarks[options.benchmark]
+    except KeyError:
+        print "Error benchmark %s has not been defined." % options.benchmark
+        print "Valid benchmarks are: %s" % DefinedBenchmarks
+        sys.exit(1)
+else:
+    if options.dual:
+        bm = [SysConfig(disk=options.disk_image, mem=options.mem_size), SysConfig(disk=options.disk_image, mem=options.mem_size)]
+    else:
+        bm = [SysConfig(disk=options.disk_image, mem=options.mem_size)]
+
+np = options.num_cpus
+
+if buildEnv['TARGET_ISA'] == "alpha":
+    test_sys = makeLinuxAlphaSystem(test_mem_mode, TestMemClass, bm[0])
+elif buildEnv['TARGET_ISA'] == "mips":
+    test_sys = makeLinuxMipsSystem(test_mem_mode, TestMemClass, bm[0])
+elif buildEnv['TARGET_ISA'] == "sparc":
+    test_sys = makeSparcSystem(test_mem_mode, TestMemClass, bm[0])
+elif buildEnv['TARGET_ISA'] == "x86":
+    test_sys = makeLinuxX86System(test_mem_mode, TestMemClass, options.num_cpus, bm[0], False)
+elif buildEnv['TARGET_ISA'] == "arm":
+    test_sys = makeArmSystem(test_mem_mode, options.machine_type, TestMemClass, bm[0],
+            options.dtb_filename, bare_metal=options.bare_metal)
+else:
+    fatal("Incapable of building %s full system!", buildEnv['TARGET_ISA'])
+
+if options.kernel is not None:
+    test_sys.kernel = binary(options.kernel)
+
+if options.script is not None:
+    test_sys.readfile = options.script
+
+test_sys.init_param = options.init_param
+
+test_sys.cpu = [TestCPUClass(cpu_id=i) for i in xrange(np)]
+
+if options.caches or options.l2cache:
+    test_sys.iocache = IOCache(clock = '1GHz',
+                               addr_ranges = test_sys.mem_ranges)
+    test_sys.iocache.cpu_side = test_sys.iobus.master
+    test_sys.iocache.mem_side = test_sys.membus.slave
+else:
+    test_sys.iobridge = Bridge(delay='50ns', ranges = test_sys.mem_ranges)
+    test_sys.iobridge.slave = test_sys.iobus.master
+    test_sys.iobridge.master = test_sys.membus.slave
+
+# Sanity check
+if options.fastmem:
+    if TestCPUClass != AtomicSimpleCPU:
+        fatal("Fastmem can only be used with atomic CPU!")
+    if (options.caches or options.l2cache):
+        fatal("You cannot use fastmem in combination with caches!")
+
+
+
+print "TestCPUClass.clock = %s " % TestCPUClass.clock
+if useNVMain:
+    test_sys.physmem.cpu_frequency = TestCPUClass.clock
+    test_sys.physmem.NVMainWarmUp = options.nvmain_warmup
+    test_sys.physmem.config = options.nvmain_config
+
+for i in xrange(np):
+    if options.fastmem:
+        test_sys.cpu[i].fastmem = True
+    if options.checker:
+        test_sys.cpu[i].addCheckerCpu()
+    test_sys.cpu[i].createThreads()
+
+CacheConfig.config_cache(options, test_sys)
+
+if len(bm) == 2:
+    if buildEnv['TARGET_ISA'] == 'alpha':
+        drive_sys = makeLinuxAlphaSystem(drive_mem_mode, bm[1])
+    elif buildEnv['TARGET_ISA'] == 'mips':
+        drive_sys = makeLinuxMipsSystem(drive_mem_mode, bm[1])
+    elif buildEnv['TARGET_ISA'] == 'sparc':
+        drive_sys = makeSparcSystem(drive_mem_mode, bm[1])
+    elif buildEnv['TARGET_ISA'] == 'x86':
+        drive_sys = makeX86System(drive_mem_mode, np, bm[1])
+    elif buildEnv['TARGET_ISA'] == 'arm':
+        drive_sys = makeArmSystem(drive_mem_mode, options.machine_type, bm[1])
+
+    drive_sys.cpu = DriveCPUClass(cpu_id=0)
+    drive_sys.cpu.createThreads()
+    drive_sys.cpu.createInterruptController()
+    drive_sys.cpu.connectAllPorts(drive_sys.membus)
+    if options.fastmem:
+        drive_sys.cpu.fastmem = True
+    if options.kernel is not None:
+        drive_sys.kernel = binary(options.kernel)
+
+    drive_sys.iobridge = Bridge(delay='50ns',
+                                ranges = drive_sys.mem_ranges)
+    drive_sys.iobridge.slave = drive_sys.iobus.master
+    drive_sys.iobridge.master = drive_sys.membus.slave
+
+    drive_sys.init_param = options.init_param
+    root = makeDualRoot(True, test_sys, drive_sys, options.etherdump)
+elif len(bm) == 1:
+    root = Root(full_system=True, system=test_sys)
+else:
+    print "Error I don't know how to create more than 2 systems."
+    sys.exit(1)
+
+if options.timesync:
+    root.time_sync_enable = True
+
+if options.frame_capture:
+    VncServer.frame_capture = True
+
+Simulation.setWorkCountOptions(test_sys, options)
+Simulation.run(options, root, test_sys, FutureClass)
diff -r 0a99ff93b4fc configs/nvmain/nvm_classic.py
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/configs/nvmain/nvm_classic.py	Tue Jun 25 13:13:40 2013 -0400
@@ -0,0 +1,198 @@
+# Copyright (c) 2006-2008 The Regents of The University of Michigan
+# All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions are
+# met: redistributions of source code must retain the above copyright
+# notice, this list of conditions and the following disclaimer;
+# redistributions in binary form must reproduce the above copyright
+# notice, this list of conditions and the following disclaimer in the
+# documentation and/or other materials provided with the distribution;
+# neither the name of the copyright holders nor the names of its
+# contributors may be used to endorse or promote products derived from
+# this software without specific prior written permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+#
+# Author: Matt Poremba
+
+
+import os
+import optparse
+import sys
+from os.path import join as joinpath
+
+import m5
+from m5.defines import buildEnv
+from m5.objects import *
+from m5.util import addToPath, fatal
+
+if buildEnv['FULL_SYSTEM']:
+    fatal("This script requires syscall emulation mode (*_SE).")
+
+addToPath('../common')
+addToPath('../topologies')
+addToPath('../ruby')
+
+import Options
+import Ruby
+import Simulation
+import CacheConfig
+from Caches import *
+from cpu2000 import *
+
+
+
+# Get paths we might need.  It's expected this file is in m5/configs/example.
+config_path = os.path.dirname(os.path.abspath(__file__))
+config_root = os.path.dirname(config_path)
+m5_root = os.path.dirname(config_root)
+
+parser = optparse.OptionParser()
+Options.addCommonOptions(parser)
+Options.addSEOptions(parser)
+
+if '--ruby' in sys.argv:
+    Ruby.define_options(parser)
+
+# Benchmark options
+parser.add_option("--stdout", action="store_true", help="Print benchmark output to stdout instead of a file.")
+parser.add_option("--nvmain_PARAM", type="string", default="NULL", help="Set NVMain configuration value for PARAM (e.g., --nvmain_RANKS 4, --nvmain_BANKS 8, etc.)")
+parser.add_option("--nvmain_warmup", action="store_true", help="Enable warm up of internal caches in NVMain (i.e., DRAMCaches, etc)")
+
+# Memory Size Options
+parser.add_option("--mem-size", action="store", type="string", default="512MB",
+                  help="Specify the physical memory size (single memory)")
+
+
+#
+#  Check for extra nvmain configuration override options and add them as options to python
+#
+argnum = 1
+for arg in sys.argv:
+    if arg[:9] == "--nvmain_" and arg != "--nvmain_warmup":
+        parser.add_option(arg, type="string", default="NULL", help="Set NVMain configuration value for PARAM")
+    argnum = argnum + 1
+
+execfile(os.path.join(config_root, "common", "Options.py"))
+
+
+#
+#  Parse arguments
+#
+(options, args) = parser.parse_args()
+
+
+numThreads = 1
+
+
+#
+#  Setup CPU classic and memory access mode based on options
+#
+(CPUClass, test_mem_mode, FutureClass) = Simulation.setCPUClass(options)
+CPUClass.clock = '2GHz'
+CPUClass.numThreads = numThreads;
+
+np = options.num_cpus
+print "Creating %d CPUs" % np
+print "Test mem mode is %s" % test_mem_mode
+
+#
+#  Create the system
+#
+system = System(cpu = [CPUClass(cpu_id=i) for i in xrange(np)],
+                membus = CoherentBus(), mem_mode = test_mem_mode)
+
+
+#
+#  Use SimpleMemory with ruby (protocol overrides to NVMainControl) and NVMainMemory for classic caches
+#
+if '--ruby' in sys.argv:
+    system.physmem = SimpleMemory(range=AddrRange(options.mem_size))
+else:
+    system.physmem = NVMainMemory(range=AddrRange(options.mem_size))
+
+options.use_map = True
+
+if options.ruby:
+    Ruby.create_system(options, system)
+    assert(options.num_cpus == len(system.ruby._cpu_ruby_ports))
+
+
+#
+#  Create the configuration overrides string for NVMain
+#
+nvmaincfg = ""
+nvmaincfgparams = ""
+nvmaincfgvalues = ""
+nvmainwarmup = False
+
+argnum = 1
+for arg in sys.argv:
+    if arg == '--nvmain_warmup':
+        nvmainwarmup = True
+
+    elif arg[:9] == "--nvmain_":
+        if nvmaincfgparams != "":
+            nvmaincfgparams += ","
+            nvmaincfgvalues += ","
+        nvmaincfgparams += arg[9:]
+        nvmaincfgvalues += sys.argv[argnum]
+
+        if arg == '--nvmain_config':
+            nvmaincfg = sys.argv[argnum]
+
+    argnum = argnum + 1
+
+
+#
+#  Pass the configuration overrides to NVMainControl or NVMainMemory depending on ruby/classic mode
+#
+if options.ruby:
+    for i in xrange(options.num_dirs):
+        exec("system.dir_cntrl%d.memBuffer.configparams = nvmaincfgparams" % i)
+        exec("system.dir_cntrl%d.memBuffer.configvalues = nvmaincfgvalues" % i)
+else:
+    system.physmem.config = nvmaincfg
+    system.physmem.configparams = nvmaincfgparams
+    system.physmem.configvalues = nvmaincfgvalues
+    system.physmem.cpu_frequency = CPUClass.clock
+    system.physmem.NVMainWarmUp = nvmainwarmup
+
+
+
+#
+#  Assign comma delimited programs to each CPU
+#
+for i in xrange(np):
+    process = LiveProcess()
+    process.executable = options.cmd
+    process.cmd = [options.cmd] + options.options.split()
+
+    system.cpu[i].workload = process
+    print "CPU %d is running process %s" % (i, process.cmd)
+
+    system.cpu[i].createInterruptController()
+
+    if options.ruby:
+        system.cpu[i].icache_port = system.ruby._cpu_ruby_ports[i].slave
+        system.cpu[i].dcache_port = system.ruby._cpu_ruby_ports[i].slave
+
+if not options.ruby:
+    system.system_port = system.membus.slave
+    system.physmem.port = system.membus.master
+    CacheConfig.config_cache(options, system)
+
+
+root = Root(full_system = False, system = system)
+Simulation.run(options, root, system, FutureClass)
